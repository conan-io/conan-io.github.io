I"gu<p>As we explained in our previous blog post about
<a href="https://blog.conan.io/2019/09/02/Deterministic-builds-with-C-C++.html">deterministic builds</a>
it is not possible to identify a compiled C/C++ artifact by its checksum, the same sources
will lead to different binaries, so there is no <em>correct</em> result we can agree on to certify
a binary.</p>

<p>This is a big problem for many industries where software is a critical component in their
products: aeronautics, medical, automotive,… almost any industry will get into trouble if
its artifacts can be tampered with without notice.</p>

<p>Conan doesn’t rely on the checksum of the binaries, but on the <strong>package ID to identify the
binaries</strong>, it is a unique identifier that encodes information about settings, options, and
requirements of each package. We will explain how knowing the package ID you can know
exactly which are the libraries deployed or even the source code used to generate the artifacts.</p>

<h2 id="how-package-id-works">How package ID works</h2>

<p>Conan computes a different package ID for any combination of the following elements:</p>
<ul>
  <li>
    <p><strong>Settings</strong>. Depending on the value of the settings declared in the recipe, a different
package ID will be computed, so different <em>operating systems</em>, <em>compilers</em>, <em>build types</em>,…
will produce different IDs.</p>
  </li>
  <li>
    <p><strong>Options</strong>. The value of the options will also be added to generate the
package ID. The same library, for example, will get a different package ID for a
static build and dynamic linking.</p>
  </li>
  <li>
    <p><strong>Requirements</strong>. Depending on the package ID mode configured for the Conan client or the
one declared for a specific requirement, different components of the full Conan 
package reference of the dependencies could affect the package ID of the consumer. It’s highly
configurable, from a mode taking into account only the name of the dependencies to other
modes including any change in the sources or even the build environment.</p>

    <p>Very important to note that transitive requirements (dependencies of my dependencies) are
only encoded into my package ID through the package reference (Conan reference, package ID
and revisions) of my requirements.</p>
  </li>
</ul>

<p><em>Note.-</em> Only the dependencies declared using the <code class="highlighter-rouge">requires</code> attribute or inside the
<code class="highlighter-rouge">requirements()</code> method will be considered, <strong><code class="highlighter-rouge">build_requires</code> don’t affect the package ID</strong>.</p>

<h2 id="a-quick-reminder-about-conan-package-reference">A quick reminder about Conan package reference</h2>

<p>Before moving on, we need to introduce what a Conan package reference is and which are its
components. A Conan package reference is the unique identifier of the products of a build that
are bundled into a package, it is compounded by the following parts:</p>

<ul>
  <li>
    <p><strong>Conan reference</strong>. It is the identifier of the recipe, like <code class="highlighter-rouge">fmt/5.3.0@bincrafters/stable</code>
for example, it contains the <em>name</em> and the <em>version</em> of the recipe, and the <em>user/channel</em>
information: <code class="highlighter-rouge">&lt;name&gt;/&lt;version&gt;@&lt;user&gt;/&lt;channel&gt;</code>.</p>

    <p>Conan v1.10 introduced <a href="https://docs.conan.io/en/latest/versioning/revisions.html">recipe revision</a>,
which is a way to version the recipe sources without touching the main components of the
recipe reference. This is an example of a full Conan reference:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">fmt</span>/5.3.0@bincrafters/stable#500ad2e039e90e5aa50b8ceb6a35a3e1
</code></pre></div>    </div>

    <p>Notice that Conan will interpret the <code class="highlighter-rouge">&lt;version&gt;</code> component as SemVer if possible.</p>
  </li>
  <li>
    <p><strong>Package ID</strong>. It is the unique identifier of the package binaries, we will elaborate on it
in the next sections in this blog post.</p>
  </li>
  <li>
    <p><strong>Package revision</strong>. Introduced in Conan v1.10, the
<a href="https://docs.conan.io/en/latest/versioning/revisions.html">package revision</a> is the hash of
the contents of the package.
As it was said before, the same sources will typically generate different binaries even using the
same environment.</p>
  </li>
</ul>

<p>Given all these components, a full Conan package reference will contain all these information
<code class="highlighter-rouge">&lt;name&gt;/&lt;version&gt;@&lt;user&gt;/&lt;channel&gt;#&lt;rrev&gt;:&lt;pkg_id&gt;#&lt;prev&gt;</code> and it identifies uniquely
every Conan package build.</p>

<h2 id="importance-of-package-id-modes">Importance of package ID modes</h2>

<p>Conan can identify every single package build, and all this information could
be propagated to the consumer’s package ID, but this would lead to a big drawback: any build
of a requirement (or transitive requirement) would modify all the package IDs down in the
dependency graph, those new IDs wouldn’t have binaries available and we would need to compile
them.</p>

<p>In some situations it is not convenient because it will consume too much compilation time
and we want to take advantage of available binaries if they are ABI compatible. However,
in other situations, that’s exactly what we want to achieve: we can’t take the risk
of a requirement changing a header file without bumping the version.</p>

<p>Here it lies the utility and importance of package ID modes, they allow to configure which
components of the full package reference should be considered to compute the package ID of
the consumer.</p>

<p>These modes go from <code class="highlighter-rouge">unrelated_mode</code> where nothing from the requirement is taken into
account to <code class="highlighter-rouge">package_revision_mode</code> where everything (including package revisions) will
modify the package ID. And there are many other modes in between. Choosing the right mode
between all the posibilities is very important:</p>
<ul>
  <li>a relaxed mode will be less intensive in terms of compilation, more binaries will be reused,
less information from the requirements will be taken into account for the package ID of
the consumer. It won’t be possible to know the exact revision from your requirements you
used to generate your package, you cannot be sure if it include a bugfix or even features
upstreams</li>
  <li>a more strict mode will gather more information from the requirements, it can be possible
to know the exact sources used to build them, but it will require a new binary for any
minor changes and compilation times in your CI can increase significatively.</li>
</ul>

<p>Choosing the right package ID mode for your project is an important decision. You should
carefully consider the versioning schema of your dependencies, your CI times, the criticality
of source code changes in your system (can a bugfix be a breaking change?),… all these
factors can be managed using the right package ID mode.</p>

<p>These modes can be configured for a Conan client (we are going to use it like that in this
blogpost), but the global behavior can be overriden for any single requirement of any
recipe using the <code class="highlighter-rouge">package_id</code> method (more about this in the
<a href="https://docs.conan.io/en/latest/creating_packages/define_abi_compatibility.html#using-package-id-for-package-dependencies">docs</a>)</p>

<h2 id="conan-default-behavior-semver_direct_mode">Conan default behavior: <code class="highlighter-rouge">semver_direct_mode</code></h2>

<p>By default, Conan uses <code class="highlighter-rouge">semver_direct_mode</code> which means that it will compute a different
package ID whenever the <em>major</em> component of the version of its requirements is different.
This is a quite relaxed method with big assumptions: all the dependencies use properly a
SemVer versioning schema, my application is not sensible to new features or bug fixes, and
it is ok to ignore changes in options or settings of my requirements.
Although it might be adequate for general-purpose libraries and the open-source community,
it is probably not the best approach for company software.</p>

<p>Let’s explore it with the example recipe in the <code class="highlighter-rouge">conanfile.py</code> below:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">conans</span> <span class="kn">import</span> <span class="n">ConanFile</span>

<span class="k">class</span> <span class="nc">Library</span><span class="p">(</span><span class="n">ConanFile</span><span class="p">):</span>

    <span class="n">name</span> <span class="o">=</span> <span class="s">"name"</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s">"version"</span>
    
    <span class="n">settings</span> <span class="o">=</span> <span class="s">"os"</span><span class="p">,</span> <span class="s">"compiler"</span><span class="p">,</span> <span class="s">"build_type"</span>
    <span class="n">options</span> <span class="o">=</span> <span class="p">{</span><span class="s">"shared"</span><span class="p">:</span> <span class="p">[</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">]}</span>
    <span class="n">default_options</span> <span class="o">=</span> <span class="p">{</span><span class="s">"shared"</span><span class="p">:</span> <span class="bp">True</span><span class="p">}</span>
    
    <span class="n">requires</span> <span class="o">=</span> <span class="s">"fmt/5.3.0@bincrafters/stable"</span>
</code></pre></div></div>

<p>Using the Conan client we can compute the package ID of the package that will
be generated with the command
<a href="https://docs.conan.io/en/latest/reference/commands/consumer/info.html#conan-info">conan info</a>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan info <span class="nb">.</span> <span class="nt">--profile</span><span class="o">=</span>default
...
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: f38e4ae2fcc1fd3b6f76fde9093cfce7d4d11f94
...
</code></pre></div></div>

<p>Besides the requirements, the ID obtained depends on the values of the settings and
options used, here we are telling Conan to use explicitly the profile <code class="highlighter-rouge">default</code>.
If you want to reproduce the same package ID values that appear in this post,
you can use this profile:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan profile show default

Configuration <span class="k">for </span>profile default:
<span class="o">[</span>settings]
<span class="nv">os</span><span class="o">=</span>Macos
<span class="nb">arch</span><span class="o">=</span>x86_64
<span class="nv">compiler</span><span class="o">=</span>apple-clang
compiler.version<span class="o">=</span>10.0
compiler.libcxx<span class="o">=</span>libc++
<span class="nv">build_type</span><span class="o">=</span>Release
<span class="o">[</span>options]
<span class="o">[</span>build_requires]
<span class="o">[</span><span class="nb">env</span><span class="o">]</span>
</code></pre></div></div>

<p>With the mode <code class="highlighter-rouge">semver_direct_mode</code>, as we’ve already said, only a change in the
<em>major</em> component of the requirements will affect the package ID value:</p>

<ul>
  <li>
    <p>If we change the version of <code class="highlighter-rouge">fmt</code> from <code class="highlighter-rouge">5.3.0</code> to <code class="highlighter-rouge">5.2.1</code>, we get the
same package id for our conanfile:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan config <span class="nb">set </span>general.default_package_id_mode<span class="o">=</span>semver_direct_mode
   
⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span> <span class="nt">--profile</span><span class="o">=</span>default
<span class="c"># when we require fmt 5.3.0</span>
<span class="nb">fmt</span>/5.3.0@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 38dbf89d158028a99d09852abf8b8a82ede43714
   
<span class="c"># when we require fmt 5.2.1</span>
⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span> <span class="nt">--profile</span><span class="o">=</span>default
<span class="nb">fmt</span>/5.2.1@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 38dbf89d158028a99d09852abf8b8a82ede43714
</code></pre></div>    </div>
  </li>
  <li>
    <p>We need to change the <em>major</em> component (to <code class="highlighter-rouge">4.1.0</code>) to get a different ID:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span> <span class="nt">--profile</span><span class="o">=</span>default
<span class="c"># when we require fmt 4.1.0</span>
<span class="nb">fmt</span>/4.1.0@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 19d34f4e911e399b2fb93166523221c5e1f14f06
</code></pre></div>    </div>
  </li>
  <li>
    <p>But changes that affect the package ID of the requirement won’t be reflected in
the package ID of the consumer:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># when we require fmt 4.1.0 (shared=True)</span>
⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span> <span class="nt">--profile</span><span class="o">=</span>default <span class="nt">-o</span> <span class="nb">fmt</span>:shared<span class="o">=</span>True
<span class="nb">fmt</span>/4.1.0@bincrafters/stable
    ID: 95b87e2c9261497d05b76244c015fbde06fe50b3
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 19d34f4e911e399b2fb93166523221c5e1f14f06
</code></pre></div>    </div>
  </li>
</ul>

<p>In the output above it is shown that the package ID for the consumer recipe
changes (from <code class="highlighter-rouge">38dbf89d</code> to <code class="highlighter-rouge">19d34f4e</code>) only when the <em>major</em> component of
the requirement <code class="highlighter-rouge">fmt</code> changes (although the package ID for <code class="highlighter-rouge">fmt</code> is the same).
And it doesn’t change if we modify an option of the <code class="highlighter-rouge">fmt</code> package, the package ID
corresponding to <code class="highlighter-rouge">fmt</code> changes but the one of the consumer recipe doesn’t.</p>

<p>With the <code class="highlighter-rouge">semver_direct_mode</code>, as long as the <em>major</em> doesn’t change, we can
modify the transitive dependencies (even add or remove them) as much as we want: we
can modify options to activate features or switch behaviors, we can use different linking
options,… it all depends on the library writer. There are many
degrees of freedom under the same package ID of our library. We won’t be able
to disambiguate as many configurations lead to the same package ID.</p>

<h2 id="other-package-id-modes">Other package ID modes</h2>

<p>There are many more package ID modes to use (see <a href="https://docs.conan.io/en/latest/creating_packages/define_abi_compatibility.html#versioning-schema">full list</a>),
here we are going to show just some of them:</p>

<ul>
  <li>
    <p><strong><code class="highlighter-rouge">full_version_mode</code></strong>: it will take into account all the components of the
SemVer version (in the following example we are modifying the <em>patch</em> component):</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan config <span class="nb">set </span>general.default_package_id_mode<span class="o">=</span>full_version_mode
   
⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span>  <span class="nt">--profile</span><span class="o">=</span>default
<span class="c"># when we require fmt 5.2.1</span>
<span class="nb">fmt</span>/5.2.1@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 840962321acb965eeab4e8507bdb9e85c11a06fd
   
⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span>  <span class="nt">--profile</span><span class="o">=</span>default
<span class="c"># when we require fmt 5.2.0</span>
<span class="nb">fmt</span>/5.2.0@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 8e9392814f9e6f0132c2e383d60364623ca759b5
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="highlighter-rouge">full_package_mode</code></strong>: any change in the package reference (excluding revisions) will
modify the package ID of the consumer recipe. Let’s see how modifying an option in the
required <code class="highlighter-rouge">fmt</code> recipe modify its package ID and a new value is computed for the
consumer package:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan config <span class="nb">set </span>general.default_package_id_mode<span class="o">=</span>full_package_mode
   
⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span>  <span class="nt">--profile</span><span class="o">=</span>default <span class="nt">-o</span> <span class="nb">fmt</span>:shared<span class="o">=</span>False
<span class="c"># when we require fmt 5.2.0 (shared=False)</span>
<span class="nb">fmt</span>/5.2.0@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 50fb56084639e9d7f970e1c79e36f53b452eb552
   
⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span>  <span class="nt">--profile</span><span class="o">=</span>default <span class="nt">-o</span> <span class="nb">fmt</span>:shared<span class="o">=</span>True
<span class="c"># with the same fmt 5.2.0, but changing option value (shared=True)</span>
<span class="nb">fmt</span>/5.2.0@bincrafters/stable
    ID: 95b87e2c9261497d05b76244c015fbde06fe50b3
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 159983fa331b57530730eaf05aedeb3628307264
</code></pre></div>    </div>
  </li>
</ul>

<p>Try other modes in your machine changing the versions of your requirements and see how the
package ID of the consumer recipe changes. All these modes provide a high level of 
customization that allows fine-grained control over the package ID.</p>

<p>The two last fields of the Conan reference of the requirements, <code class="highlighter-rouge">user</code> and <code class="highlighter-rouge">channel</code> does
not affect for most of the package ID modes, only <code class="highlighter-rouge">full_recipe_mode</code> and <code class="highlighter-rouge">full_package_mode</code>
(and modes for revisions that we’ll write about below) will take them into account.</p>

<h2 id="working-with-revisions">Working with revisions</h2>

<p>Conan v1.10.0 introduced
<a href="https://docs.conan.io/en/latest/versioning/revisions.html">revisions for recipes and packages</a>,
although the feature is experimental we are pretty sure that it arrived to stay and
will become stable soon. Revisions for recipes (<code class="highlighter-rouge">&lt;rrev&gt;</code>) provide a way to version the recipe
sources without changing the version of the recipe itself, while package revisions (<code class="highlighter-rouge">&lt;prev&gt;</code>) are a
way to differentiate binaries built using exactly the same recipe sources (see
<a href="https://blog.conan.io/2019/09/02/Deterministic-builds-with-C-C++.html">reproducible builds</a>).</p>

<p>In Conan v1.17.0 two new modes were added to the available list of package ID modes to
optionally consider these components of the full Conan reference (<code class="highlighter-rouge">&lt;ref&gt;#&lt;rrev&gt;:&lt;pkg_id&gt;#&lt;prev&gt;</code>)
of the requirements. These modes are:</p>

<ul>
  <li><strong><code class="highlighter-rouge">recipe_revision_mode</code></strong>: it is like the <code class="highlighter-rouge">full_package_mode</code>, but it takes into account
the recipe revision too.</li>
  <li><strong><code class="highlighter-rouge">package_revision_mode</code></strong>: additionally it takes into account the package revision.</li>
</ul>

<p>Using these modes, Conan will compute a new package ID for any change in the requirements, usually
it’s more than needed but it’s the safest way to ensure binary traceability and reproducibility:
only the same set of requirements configured the same way will be able to generate the same
package ID, and with the mode <code class="highlighter-rouge">package_revision_mode</code> only using the same actual binaries will
generate the same package ID.</p>

<h3 id="recipe_revision_mode">recipe_revision_mode</h3>

<p>To play the following example we need to activate revisions and use different revisions of
the requirements. Take into account that the Conan cache will store only one revision at a time,
you will need to use one Artifactory server (download free
<a href="https://jfrog.com/open-source/#conan">JFrog Artifactory Community Edition for C/C++</a>)
or Bintray if you want to persist them. Follow these steps for the <code class="highlighter-rouge">recipe_revision_mode</code>:</p>

<ol>
  <li>
    <p>Configure Conan for this example:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan config <span class="nb">set </span>general.revisions_enabled<span class="o">=</span>1
⇒  conan config <span class="nb">set </span>general.default_package_id_mode<span class="o">=</span>recipe_revision_mode
</code></pre></div>    </div>
  </li>
  <li>
    <p>Check the ID generated with one revision of the <code class="highlighter-rouge">fmt</code> requirement:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  git clone https://github.com/bincrafters/conan-fmt.git
⇒  <span class="nb">cd </span>conan-fmt
⇒  git checkout 7d9dce3
⇒  conan <span class="nb">export</span> <span class="nb">.</span> bincrafters/stable
...
<span class="nb">fmt</span>/5.3.0@bincrafters/stable: Exported revision: 500ad2e039e90e5aa50b8ceb6a35a3e1
</code></pre></div>    </div>

    <p>We can ask Conan to compute the package ID of our consumer recipe, it will use the
recipe of the <code class="highlighter-rouge">fmt</code> library that we have just exported:</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span>  <span class="nt">--profile</span><span class="o">=</span>default
<span class="nb">fmt</span>/5.3.0@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 46516d5f2debf0f4b7e55da9e75bfe277d26a1fc  
</code></pre></div>    </div>
  </li>
  <li>
    <p>We can modify the recipe of <code class="highlighter-rouge">fmt</code> to generate a different revision, and export it
to the Conan cache (it will override the existing one as only one revision can be in the
cache at a time):</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  git clone https://github.com/bincrafters/conan-fmt.git
⇒  <span class="nb">cd </span>conan-fmt
⇒  git checkout 7d9dce3
⇒  <span class="nb">echo</span> <span class="s2">"# Add a comment at the end of the file"</span> <span class="o">&gt;&gt;</span> conanfile.py
⇒  conan <span class="nb">export</span> <span class="nb">.</span> bincrafters/stable
...
<span class="nb">fmt</span>/5.3.0@bincrafters/stable: Exported revision: 30bb32c064e1c43b70d5cb9e2749e484
</code></pre></div>    </div>

    <p>If we compute the package ID of our consumer recipe, now it is a different one,
and only the recipe revision of the <code class="highlighter-rouge">fmt</code> package has changed.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span>  <span class="nt">--profile</span><span class="o">=</span>default
<span class="nb">fmt</span>/5.3.0@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: 859c7995b3e1554bd4a456aee82a45f0c6ade2f7  
</code></pre></div>    </div>
  </li>
</ol>

<h3 id="package_revision_mode">package_revision_mode</h3>

<p>As a final section related to the revisions, if we try to compute the package ID of our recipe using
the <code class="highlighter-rouge">package_revision_mode</code> Conan will take into account the package revision of the
requirements too. Let’s see what happens if the binaries for the <code class="highlighter-rouge">fmt</code> recipe are not 
available:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan remove <span class="nb">fmt</span>/5.3.0@bincrafters/stable <span class="nt">-p</span>
⇒  conan config <span class="nb">set </span>general.default_package_id_mode<span class="o">=</span>package_revision_mode

⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span> <span class="nt">--profile</span><span class="o">=</span>default       
<span class="nb">fmt</span>/5.3.0@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: Package_ID_unknown
</code></pre></div></div>

<p>With this mode enabled, Conan cannot compute the package ID because it cannot know the package
revision of the <code class="highlighter-rouge">fmt</code> package it would use if it were available. Once we compile the binary,
Conan will be able to compute the package ID:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⇒  conan <span class="nb">install fmt</span>/5.3.0@bincrafters/stable <span class="nt">--profile</span><span class="o">=</span>default <span class="nt">--build</span> <span class="nb">fmt</span>

⇒  conan config <span class="nb">set </span>general.default_package_id_mode<span class="o">=</span>package_revision_mode
⇒  conan info <span class="nb">.</span> <span class="nt">--only</span> <span class="nb">id</span> <span class="nt">--profile</span><span class="o">=</span>default         
<span class="nb">fmt</span>/5.3.0@bincrafters/stable
    ID: 853c4b61e2571e98cd7b854c1cda6bc111b8b32c
conanfile.py <span class="o">(</span>name/version<span class="o">)</span>
    ID: b2110045f8b2598a521adad9753eb610ba4059ee
</code></pre></div></div>

<p>Remember that the package ID of our consumer recipe is taking into account the package revision
of <code class="highlighter-rouge">fmt</code>, which is computed using the checksum of the generated binaries, so every
compilation will get a different package revision for that requirement and the computed
package ID will be different. That’s the reason why you can’t get the same value of the last
example, neither we can, there will be a new value with each compilation of the
<code class="highlighter-rouge">fmt</code> library.</p>

<div class="bs-callout bs-callout-info">
    <strong><code class="highlighter-rouge">package_revision_mode</code> is guaranteed to be exact:</strong> 
the package ID would only be reproduced using the same set of libraries and the same graph of
dependencies that were used to build the binary at the time.
</div>

<h2 id="conclusion">Conclusion</h2>

<p>Conan package ID modes allow fine-grained control to choose how the dependencies
may affect the package ID of consumer libraries, if you make the deploy of your applications
using Conan packages and keep track of these identifiers, you can control which are the
libraries included in any release and how they were compiled and configured.</p>

<p>More sensitive software should use more strict modes, while the community will typically
use relaxed modes, but with Conan it is easy to change the mode as we’ve seen along with the post,
it is just a value in the Conan settings.</p>

<p>With a good understanding of package ID modes and some powerful features like
<a href="https://docs.conan.io/en/latest/versioning/lockfiles.html#how-to-use-lockfiles-in-ci">lockfiles</a>
it is possible to setup a robust CI mechanism to coordinate the libraries to build given
any change in a dependency. Conan will know which binaries can be reused and which ones have to be
rebuilt, it will tell you too the build order and which libraries can be built in parallel. All
this information is very helpful to optimize build times and help you to make your release cycle
much faster.</p>
:ET