I"uN<p>The <strong>Raspberry PI</strong> is an amazing mini computer, powerful and cheap, the dream of hobbyists and developers around the world. With its potential to implement embedded systems, it is common to use C/C++ for developing its code, specially when efficiency and performance is relevant. However, even if it is a powerful system for the money, it can be slow while building relatively large C/C++ libraries, so cross-building can be very convenient for developers.</p>

<p>This post will describe how to setup cross building to the Raspberry PI from Windows (from Linux it is also possible, and the configuration would be very similar). A library will be cross-built, a conan package will be uploaded to a server (can be a conan_server, conan.io, or Artifactory), and then such library will be installed and used from the Raspberry PI, i.e. we will build an app and link it against this cross-built library. As bonus points, this post will also explain how to bundle the source code in the package itself, so later the library can be debugged from the Raspberry PI.</p>

<p class="centered">
<img src="http://localhost:4000/assets/post_images/2017_03_30/rpi_cross_build.png" width="70%" />
</p>

<h1 id="hello-world-library">Hello world library</h1>

<p>The library that will be built and packaged is the one existing in <a href="https://github.com/memsharded/hello">this github repo</a>. It is just a simple C++ “Hello world” library project, using CMake, and nothing special or conan related in it.</p>

<p>We will then start with a package template created with the <code class="highlighter-rouge">conan new</code> command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan new Hello/0.1@user/testing <span class="nt">-t</span>  <span class="c"># use your own user</span>
</code></pre></div></div>

<p>Now, lets just replace the root <code class="highlighter-rouge">conanfile.py</code> with this one:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">conans</span> <span class="kn">import</span> <span class="n">ConanFile</span><span class="p">,</span> <span class="n">CMake</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="k">class</span> <span class="nc">HelloConan</span><span class="p">(</span><span class="n">ConanFile</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Hello"</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s">"0.1"</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="s">"os"</span><span class="p">,</span> <span class="s">"compiler"</span><span class="p">,</span> <span class="s">"build_type"</span><span class="p">,</span> <span class="s">"arch"</span>

    <span class="k">def</span> <span class="nf">source</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s">"git clone https://github.com/memsharded/hello.git"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cmake</span> <span class="o">=</span> <span class="n">CMake</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
        <span class="n">gcc_dbg_src</span> <span class="o">=</span> <span class="s">""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">compiler</span> <span class="o">==</span> <span class="s">"gcc"</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">build_type</span> <span class="o">==</span> <span class="s">"Debug"</span><span class="p">:</span>
            <span class="n">gcc_dbg_src</span> <span class="o">=</span>  <span class="s">' -DCMAKE_CXX_FLAGS="-fdebug-prefix-map=</span><span class="si">%</span><span class="s">s/hello=src"'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s">'cmake hello </span><span class="si">%</span><span class="s">s </span><span class="si">%</span><span class="s">s'</span> <span class="o">%</span> <span class="p">(</span><span class="n">cmake</span><span class="o">.</span><span class="n">command_line</span><span class="p">,</span> <span class="n">gcc_dbg_src</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s">"cmake --build . </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">cmake</span><span class="o">.</span><span class="n">build_config</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">package</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">"*.h"</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="s">"include"</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="s">"hello"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">compiler</span> <span class="o">==</span> <span class="s">"gcc"</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">build_type</span> <span class="o">==</span> <span class="s">"Debug"</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">"*.cpp"</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="s">"src"</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="s">"hello"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">"*.lib"</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="s">"lib"</span><span class="p">,</span> <span class="n">keep_path</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">"*.a"</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="s">"lib"</span><span class="p">,</span> <span class="n">keep_path</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">package_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpp_info</span><span class="o">.</span><span class="n">libs</span> <span class="o">=</span> <span class="p">[</span><span class="s">"hello"</span><span class="p">]</span>
</code></pre></div></div>

<p>It is very similar to the one created by the template, but with two minor differences. First, as we want to be able to debug the packages in the Raspberry PI, it is necessary to define the gcc flag <code class="highlighter-rouge">debug-prefix-map</code>, so it points to the relative source folder <code class="highlighter-rouge">src</code> instead of the original one. Because we are going to debug in a different machine, where the original absolute source path will make no sense. Se we just define the flag to CMake (conditionally for the <code class="highlighter-rouge">gcc</code> and <code class="highlighter-rouge">Debug</code> settings):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">compiler</span> <span class="o">==</span> <span class="s">"gcc"</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">build_type</span> <span class="o">==</span> <span class="s">"Debug"</span><span class="p">:</span>
    <span class="n">gcc_dbg_src</span> <span class="o">=</span>  <span class="s">' -DCMAKE_CXX_FLAGS="-fdebug-prefix-map=</span><span class="si">%</span><span class="s">s/hello=src"'</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getcwd</span><span class="p">()</span>
</code></pre></div></div>

<p>Then, we just copy the sources <code class="highlighter-rouge">*.cpp</code> to the final package (only for the same settings too.)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">compiler</span> <span class="o">==</span> <span class="s">"gcc"</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">build_type</span> <span class="o">==</span> <span class="s">"Debug"</span><span class="p">:</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">"*.cpp"</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="s">"src"</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="s">"hello"</span><span class="p">)</span>
</code></pre></div></div>

<p>This package recipe could be tested natively, by just running:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan test_package
Hello world!
</code></pre></div></div>

<h1 id="setting-the-cross-build-toolchain">Setting the cross-build toolchain</h1>
<p>For this example, we are going to use the <a href="http://gnutoolchains.com/raspberry/">SysProg toolchain</a>.
We are using the 4.6.3 toolchain, with complete sysroot, which is very convenient. We download the tool, install it in <code class="highlighter-rouge">C:\SysGCC\Raspberry</code> and add <code class="highlighter-rouge">C:/SysGCC/Raspberry/bin/</code> to the system PATH.</p>

<p>Now we could just specify cross compilers to the conan command as arguments, like <code class="highlighter-rouge">conan test_package -e CXX=some_gcc_compiler</code>, but we can make it easier using a <strong>conan profile</strong>. So we create a file in <code class="highlighter-rouge">&lt;userhome&gt;/.conan/profiles/rpi_gcc46</code> with the following:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[settings]
    os: Linux
    compiler: gcc
    compiler.version: 4.6
    compiler.libcxx: libstdc++
    build_type: Debug
    arch: armv6
[env]
    CC=arm-linux-gnueabihf-gcc
    CXX=arm-linux-gnueabihf-g++
</code></pre></div></div>
<p>Note the <code class="highlighter-rouge">armv6</code> architecture and <code class="highlighter-rouge">Linux</code> settings, need to be defined, because the default conan settings will correspond to the Windows development box.</p>

<p>As the resulting binary won’t be executable in windows, we change the <code class="highlighter-rouge">test_package/conanfile.py</code> so the <code class="highlighter-rouge">test()</code> method just checks the existence of the binary:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">platform</span><span class="o">.</span><span class="n">system</span> <span class="p">()</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">os</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="s">"bin/example"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s">"."</span><span class="p">,</span> <span class="s">"bin"</span><span class="p">,</span> <span class="s">"example"</span><span class="p">]))</span>
</code></pre></div></div>

<p>With this configuration, creating a debug package for the R-PI, can be just done with:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan test_package <span class="nt">-pr</span><span class="o">=</span>rpi_gcc46
</code></pre></div></div>

<h1 id="uploading-and-installing-in-the-raspberry-pi">Uploading and installing in the Raspberry PI</h1>

<p>Once the package has been created locally, it can be uploaded to any conan remote server (conan.io, Artifactory, conan_server):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan upload Hello/0.1@user/testing <span class="nt">-r</span><span class="o">=</span>myremote <span class="nt">--all</span>
</code></pre></div></div>

<p>In the Raspberry PI side, we will just create a very simple consumer project with an <code class="highlighter-rouge">example.cpp</code> file:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "hello.h"
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
   <span class="n">hello</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>a <code class="highlighter-rouge">CMakeLists.txt</code> script to build it:</p>

<div class="language-cmake highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">Project</span><span class="p">(</span>Consumer<span class="p">)</span>
<span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 2.8.9<span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/conanbuildinfo.cmake<span class="p">)</span>
<span class="nf">conan_basic_setup</span><span class="p">()</span>

<span class="nb">add_executable</span><span class="p">(</span>example example.cpp<span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span>example <span class="si">${</span><span class="nv">CONAN_LIBS</span><span class="si">}</span><span class="p">)</span>
</code></pre></div></div>

<p>and the <code class="highlighter-rouge">conanfile.txt</code> to install dependencies:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[requires]
Hello/0.1@diego/testing

[generators]
cmake

[imports]
src, *.cpp -&gt; src
</code></pre></div></div>

<p>Note how the the <code class="highlighter-rouge">.cpp</code> sources are copied (“imported”) from the package, to the current binary folder, so the debugger can easily locate them.</p>

<p>Installing the cross-built “Hello” package is easy, now we don’t need profiles, as the R-PI defaults are good, so we just set the <code class="highlighter-rouge">build_type</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan <span class="nb">install</span> .. <span class="nt">-s</span> <span class="nv">build_type</span><span class="o">=</span>Debug
</code></pre></div></div>

<h1 id="building-and-debugging">Building and debugging</h1>

<p>Building our R-PI app is now standard cmake process:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir </span>build <span class="o">&amp;&amp;</span> <span class="nb">cd </span>build
<span class="nv">$ </span>cmake .. <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Debug
<span class="nv">$ </span>cmake <span class="nt">--build</span> <span class="nb">.</span>
<span class="nv">$ </span>bin/example
Hello World!
</code></pre></div></div>

<p>The good thing, is that for this example we have built it for Debug, mode, so we can debug the application and <code class="highlighter-rouge">step</code> into the package library code:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>gdb bin/example
<span class="o">&gt;</span> ...
<span class="o">&gt;</span> Reading symbols from /home/pi/consumer/build/bin/example...done.
<span class="o">(</span>gdb<span class="o">)</span> start
Temporary breakpoint 1 at 0x8914: file /home/pi/consumer/example.cpp, line 4.
Starting program: /home/pi/consumer/build/bin/example
<span class="o">(</span>gdb<span class="o">)</span> step
hello <span class="o">()</span> at src/hello.cpp:5
5               std::cout &lt;&lt; <span class="s2">"Hello World!</span><span class="se">\n</span><span class="s2">"</span><span class="p">;</span>
</code></pre></div></div>

<p>And voilá, we can see the <code class="highlighter-rouge">hello.cpp</code> source code line!</p>

<h1 id="conclusions">Conclusions</h1>

<p>Conan is a pure python app, so installing it in the Raspberry PI was as easy as <code class="highlighter-rouge">sudo pip install conan</code>.</p>

<p>In this example we have shown how to create packages with debug information for <code class="highlighter-rouge">gcc</code> and <code class="highlighter-rouge">gdb</code>, but similar approaches can be implemented for other platforms too, for example, packaging the <code class="highlighter-rouge">.pdb</code> files of Visual Studio.</p>

<p>As conan is very orthogonal to the build system and compiler, cross building packages with conan is straightforward. Profiles are a very convenient feature to gather together settings, options and environment variables, for easy switching between different development environment and targets.</p>

<p>When cross-building toolchains are more complicated, things can require a bit more of configuration to take into account the variability of those toolchains, but can be certainly done. We are aware of conan users actively using conan to package for Android and iOS systems. In any case, we are preparing some major improvements for management of build requirements, like the Android toolchain, that you will surely love. Keep tuned, follow us on <a href="https://twitter.com/conan_io">twitter</a> or subscribe to our release annoucements mailing list!</p>
:ET