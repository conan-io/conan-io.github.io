I"Û^<p>No, conan is not aiming to replace any Python package manager like pip/PyPi.
Sorry for the click-bait title, but when we realized what conan was able to do, we couldn‚Äôt avoid it :)</p>

<p>Conan is a C and C++ package manager, and to deal with the vast variability of C and C++ build systems, compilers, configurations, etc., it was designed with a great flexibility in mind, trying to let the users do almost what they want. This is one of the reasons to use Python as the scripting language for conan package recipes.</p>

<p>With this flexibility, conan is able to do very different tasks: it is able to <a href="http://blog.conan.io/2016/06/01/Building-and-packaging-C++-modules-in-VS2015.html">package Visual Studio modules</a>, also to <a href="http://docs.conan.io/en/latest/examples/go.html">package go-lang packages</a>, build packages from sources, from binaries retrieved from elsewhere, etc.</p>

<p>The story started when some users requested a solution to be able to share common python code among their package recipes. Maybe that python code could be managed separately, but being conan a package manager, they requested if they could put the common code in a conan package. So we thought, why not, we already did a proof of concept for other languages as go-lang, should be possible. And it turned out that with very little effort conan can be used as a package manager for Python too. Lets see how:</p>

<h2 id="a-basic-python-package">A basic python package</h2>

<p>Let‚Äôs begin with a simple python package, a ‚Äúhello world‚Äù functionality that we want to package and reuse:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Hello World from Python!"</span><span class="p">)</span>
</code></pre></div></div>

<p>To create a package, all we need to do is create the following layout:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-| hello.py
 | __init__.py
 | conanfile.py
</code></pre></div></div>

<p>The <code class="highlighter-rouge">__init__.py</code> is blank.
It is not necessary to compile code, so the package recipe <code class="highlighter-rouge">conanfile.py</code> is quite simple:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">conans</span> <span class="kn">import</span> <span class="n">ConanFile</span>

<span class="k">class</span> <span class="nc">HelloPythonConan</span><span class="p">(</span><span class="n">ConanFile</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"HelloPy"</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s">"0.1"</span>
    <span class="n">exports</span> <span class="o">=</span> <span class="s">'*'</span>
    <span class="n">build_policy</span> <span class="o">=</span> <span class="s">"missing"</span>

    <span class="k">def</span> <span class="nf">package</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">'*.py'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">package_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env_info</span><span class="o">.</span><span class="n">PYTHONPATH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">package_folder</span><span class="p">)</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">exports</code> will copy both the <code class="highlighter-rouge">hello.py</code> and the <code class="highlighter-rouge">__init__.py</code> into the recipe. The <code class="highlighter-rouge">package()</code> method is also obvious: to construct the package just copy the python sources.</p>

<p>The <code class="highlighter-rouge">package_info()</code> adds the current package folder to the <code class="highlighter-rouge">PYTHONPATH</code> conan environment variable. It will not affect the real environment variable unless the end user want it.</p>

<p>It can be seen that this recipe would be practically the same for most python packages, so it could be factored in a <code class="highlighter-rouge">PythonConanFile</code> base class to further simplify it (open a feature request, or better a pull request :) )</p>

<p>With this recipe, all we have to do is:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan <span class="nb">export </span>memsharded/testing
<span class="nv">$ </span>conan search
</code></pre></div></div>

<p>Of course if you want to share the package with your team, you can <code class="highlighter-rouge">conan upload</code> it to a remote server. But to create and test the package, we can do everything locally.</p>

<p>Now the package is ready for consumption. In another folder, we can create a <code class="highlighter-rouge">conanfile.txt</code> (or a <code class="highlighter-rouge">conanfile.py</code> if we prefer):</p>

<pre><code class="language-txt">[requires]
HelloPy/0.1@memsharded/testing
</code></pre>

<p>And install it with the following command:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan <span class="nb">install</span> <span class="nt">-g</span> virtualenv
</code></pre></div></div>

<p>Creating the above <code class="highlighter-rouge">conanfile.txt</code> might be unnecessary for this simple example, as you can directly run <code class="highlighter-rouge">conan install HelloPy/0.1@memsharded/testing -g virtualenv</code>, however, using the file is the canonical way.</p>

<p>The specified <code class="highlighter-rouge">virtualenv</code> generator will create an <code class="highlighter-rouge">activate</code> script (in Windows <code class="highlighter-rouge">activate.bat</code>), that basically contains the environment, in this case, the <code class="highlighter-rouge">PYTHONPATH</code>. Once we activate it, we are able to find the package in the path and use it:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>activate
<span class="nv">$ </span>python
Python 2.7.12 <span class="o">(</span>v2.7.12:d33e0cf91556, Jun 27 2016, 15:19:22<span class="o">)</span> <span class="o">[</span>MSC v.1500 32 bit <span class="o">(</span>Intel<span class="o">)]</span> on win32
...
<span class="o">&gt;&gt;&gt;</span> import hello
<span class="o">&gt;&gt;&gt;</span> hello.hello<span class="o">()</span>
Hello World from Python!
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div></div>

<p>The above shows an interactive session, but you can import also the functionality in a regular python script!</p>

<p>And this is basically it! Everything you get from conan, you can easily use it for python: transitives dependencies, conflict resolution, dependency overriding‚Ä¶ as well as all the advanced steps that conan provides: <code class="highlighter-rouge">build()</code>, <code class="highlighter-rouge">package()</code>, <code class="highlighter-rouge">package_info()</code>, having different packages for different platforms, managing different remotes in git-like decentralized architecture‚Ä¶</p>

<p>As advanced in the introduction, the real goal of this functionality was to have reusable python code among conan recipes for C and C++ packages. Let`s see how can it be done:</p>

<h2 id="reusing-python-code-in-your-recipes">Reusing python code in your recipes</h2>

<p>As the conan recipes are python code itself, it is easy to reuse python packages in them. A basic recipe using the created package would be:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">conans</span> <span class="kn">import</span> <span class="n">ConanFile</span><span class="p">,</span> <span class="n">tools</span>

<span class="k">class</span> <span class="nc">HelloPythonReuseConan</span><span class="p">(</span><span class="n">ConanFile</span><span class="p">):</span>
    <span class="n">requires</span> <span class="o">=</span> <span class="s">"HelloPy/0.1@memsharded/testing"</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">tools</span><span class="o">.</span><span class="n">pythonpath</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="kn">from</span> <span class="nn">hello</span> <span class="kn">import</span> <span class="n">hello</span>
            <span class="n">hello</span><span class="p">()</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">requires</code> section is just referencing the previously created package. The functionality of that package can be used in several methods of the recipe: <code class="highlighter-rouge">source()</code>, <code class="highlighter-rouge">build()</code>, <code class="highlighter-rouge">package()</code> and <code class="highlighter-rouge">package_info()</code>, i.e. all of the methods used for creating the package itself. Note that in other places it is not possible, as it would require the dependencies of the recipe to be already retrieved, and such dependencies cannot be retrieved until the basic evaluation of the recipe has been executed.</p>

<p>In the above example, the code is reused in the <code class="highlighter-rouge">build()</code> method as an example. Note the use of a helper context, which basically activates/deactivates the <code class="highlighter-rouge">PYTHONPATH</code> environment variable with the value assigned in the package. We didn‚Äôt want to do this activation implicit for all conan packages, but rather make it explicit.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">$</span> <span class="n">conan</span> <span class="n">install</span> <span class="o">-</span><span class="n">g</span> <span class="n">env</span> <span class="o">-</span><span class="n">g</span> <span class="n">txt</span>
<span class="o">...</span>
<span class="err">$</span> <span class="n">conan</span> <span class="n">build</span>
<span class="n">Hello</span> <span class="n">World</span> <span class="k">from</span> <span class="n">Python</span><span class="err">!</span>
</code></pre></div></div>

<h2 id="a-full-python-and-cc-package-manager">A full python and C/C++ package manager</h2>

<p>Once we realized what could be achieved with this functionality, we couldn‚Äôt resist to try a full application. The real utility of this is that conan is a C and C++ package manager. So if we want to create a python package that wraps the functionality of, lets say the Poco C++ library, it can be easily done. Poco itself has transitive (C/C++) dependencies, but they are already handled by conan. Furthermore, a very interesting thing is that nothing has to be done in advance for that library, thanks to useful tools as <strong>pybind11</strong>, that allows to create python bindings easily.</p>

<p>So let‚Äôs build a package with the following files:</p>

<ul>
  <li><code class="highlighter-rouge">conanfile.py</code>: The package recipe</li>
  <li><code class="highlighter-rouge">__init__.py</code>: necessary file, blank</li>
  <li><code class="highlighter-rouge">pypoco.cpp</code>: The C++ code with the <code class="highlighter-rouge">pybind11</code> wrapper for Poco that generates a python extension (a shared library that can be imported from python)</li>
  <li><code class="highlighter-rouge">CMakeLists.txt</code>: cmake build file that is able to compile <code class="highlighter-rouge">pypoco.cpp</code> into a python extension (<code class="highlighter-rouge">pypoco.pyd</code> in Windows, <code class="highlighter-rouge">pypoco.so</code> in Linux)</li>
  <li><code class="highlighter-rouge">poco.py</code>: A python file that makes use of the pypoco python binary extension built with <code class="highlighter-rouge">pypoco.cpp</code></li>
  <li><code class="highlighter-rouge">test_package/conanfile.py</code>: A test consumer recipe to create and test the package</li>
</ul>

<p>The <code class="highlighter-rouge">pypoco.cpp</code> file can be coded easily thanks to the elegant <code class="highlighter-rouge">pybind11</code> library:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;pybind11/pybind11.h&gt;
#include "Poco/Random.h"
</span>
<span class="k">using</span> <span class="n">Poco</span><span class="o">::</span><span class="n">Random</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">py</span> <span class="o">=</span> <span class="n">pybind11</span><span class="p">;</span>

<span class="n">PYBIND11_PLUGIN</span><span class="p">(</span><span class="n">pypoco</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">py</span><span class="o">::</span><span class="n">module</span> <span class="n">m</span><span class="p">(</span><span class="s">"pypoco"</span><span class="p">,</span> <span class="s">"pybind11 example plugin"</span><span class="p">);</span>
    <span class="n">py</span><span class="o">::</span><span class="n">class_</span><span class="o">&lt;</span><span class="n">Random</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s">"Random"</span><span class="p">)</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="n">py</span><span class="o">::</span><span class="n">init</span><span class="o">&lt;&gt;</span><span class="p">())</span>
        <span class="p">.</span><span class="n">def</span><span class="p">(</span><span class="s">"nextFloat"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Random</span><span class="o">::</span><span class="n">nextFloat</span><span class="p">);</span> 
    <span class="k">return</span> <span class="n">m</span><span class="p">.</span><span class="n">ptr</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And the <code class="highlighter-rouge">poco.py</code> file is straigthforward:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">pypoco</span>

<span class="k">def</span> <span class="nf">random_float</span><span class="p">():</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">pypoco</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">nextFloat</span><span class="p">()</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">conanfile.py</code> has a few more lines than the above, but still quite easy to understand:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">conans</span> <span class="kn">import</span> <span class="n">ConanFile</span><span class="p">,</span> <span class="n">tools</span><span class="p">,</span> <span class="n">CMake</span>

<span class="k">class</span> <span class="nc">PocoPyReuseConan</span><span class="p">(</span><span class="n">ConanFile</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"PocoPy"</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s">"0.1"</span>
    <span class="n">requires</span> <span class="o">=</span> <span class="s">"Poco/1.7.3@lasote/stable"</span><span class="p">,</span> <span class="s">"pybind11/any@memsharded/stable"</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="s">"os"</span><span class="p">,</span> <span class="s">"compiler"</span><span class="p">,</span> <span class="s">"arch"</span><span class="p">,</span> <span class="s">"build_type"</span>
    <span class="n">exports</span> <span class="o">=</span> <span class="s">"*"</span>
    <span class="n">generators</span> <span class="o">=</span> <span class="s">"cmake"</span>
    <span class="n">build_policy</span> <span class="o">=</span> <span class="s">"missing"</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cmake</span> <span class="o">=</span> <span class="n">CMake</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>
        <span class="n">pythonpaths</span> <span class="o">=</span> <span class="s">"-DPYTHON_INCLUDE_DIR=C:/Python27/include -DPYTHON_LIBRARY=C:/Python27/libs/python27.lib"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s">'cmake </span><span class="si">%</span><span class="s">s </span><span class="si">%</span><span class="s">s -DEXAMPLE_PYTHON_VERSION=2.7'</span> <span class="o">%</span> <span class="p">(</span><span class="n">cmake</span><span class="o">.</span><span class="n">command_line</span><span class="p">,</span> <span class="n">pythonpaths</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="s">"cmake --build . </span><span class="si">%</span><span class="s">s"</span> <span class="o">%</span> <span class="n">cmake</span><span class="o">.</span><span class="n">build_config</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">package</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">'*.py*'</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">"*.so"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">package_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env_info</span><span class="o">.</span><span class="n">PYTHONPATH</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">package_folder</span><span class="p">)</span>
</code></pre></div></div>

<p>The recipe now declares 2 <code class="highlighter-rouge">requires</code>, the Poco library and the pybind11 library that we will be using to create the binary extension.</p>

<p>As we are actually building some C++ code, we need a few important things:</p>

<ul>
  <li>
    <p>Input <code class="highlighter-rouge">settings</code> that define the OS, compiler, version and architecture we are using to build our extension. This is necessary, as we will see later, the binary we are building must match the architecture of the python interpreter that we will be using</p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">build()</code> method is used to actually invoke <code class="highlighter-rouge">cmake</code>. See in my case I have had to hardcode the python path in the example, as the <code class="highlighter-rouge">CMakeLists.txt</code> call to <code class="highlighter-rouge">find_package(PythonLibs)</code> didn‚Äôt find my python installed in <code class="highlighter-rouge">C:/Python27</code>, quite a standard path. I have added the <code class="highlighter-rouge">cmake generator</code> too, to be able to easily use the declared <code class="highlighter-rouge">requires</code> build information inside my <code class="highlighter-rouge">CMakeLists.txt</code></p>
  </li>
  <li>
    <p>The <code class="highlighter-rouge">CMakeLists.txt</code> is not posted here, but is basically the one used by pybind11 example, with just 2 lines to include the conan generated cmake file for dependencies. It can be inspected in the github repo.</p>
  </li>
  <li>
    <p>Note that in my example I am just using Python 2.7 as an input option. If necessary, more options for other interpreters/architectures could be easily provided, as well as to avoiding the hardcoded paths. Even the python interpreter itself could be packaged in a conan package, we have been reported by some users doing so.</p>
  </li>
</ul>

<p>The above recipe will generate a different binary for different compilers or versions. As the binary is being wrapped by python, we could avoid this and use the same binary for different setups, modifying this behavior with the <code class="highlighter-rouge">conan_info()</code> method.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan <span class="nb">export </span>memsharded/testing
<span class="nv">$ </span>conan <span class="nb">install </span>PocoPy/0.1@memsharded/testing <span class="nt">-s</span> <span class="nb">arch</span><span class="o">=</span>x86 <span class="nt">-g</span> virtualenv
<span class="nv">$ </span>activate
<span class="nv">$ </span>python
<span class="o">&gt;&gt;&gt;</span> import poco
<span class="o">&gt;&gt;&gt;</span> poco.random_float<span class="o">()</span>
0.697845458984375
</code></pre></div></div>

<p>Now the <code class="highlighter-rouge">conan install</code> first invocation will build retrieve the dependencies and build the package. Next invocation will use the cached binaries and be much faster. Note how we have to specify <code class="highlighter-rouge">-s arch=x86</code> to build matching the architecture of the python interpreter to be used, in our case, 32 bits.</p>

<p>Also, in the <code class="highlighter-rouge">conan install</code> output we can read the dependencies that are being pulled:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Requirements
    OpenSSL/1.0.2h@lasote/stable from conan.io
    Poco/1.7.3@lasote/stable from conan.io
    PocoPy/0.1@memsharded/testing from <span class="nb">local
    </span>pybind11/any@memsharded/stable from conan.io
    zlib/1.2.8@lasote/stable from conan.io
</code></pre></div></div>

<p>This is the great thing about using conan for this task, by depending on Poco, other C and C++ transitive dependencies are being retrieved and used in the application.</p>

<p>If you want to have a further look to the code of these examples, you can check <a href="https://github.com/memsharded/python-conan-packages">this github repo</a>. The above examples and code have been tested only in Win10, VS14u2, but might work with other configurations with little or no extra work (but haven‚Äôt tested)</p>

<h2 id="conclusion">Conclusion</h2>

<p>Obviously, this does not try to compete with other python package managers. Conan is a C and C++ package manager, focused on C and C++ developers. But when we realized that this was possible, we thought it was a good way to showcase the power, simplicity and versatility of conan as a package manager.</p>

<p>And of course, if you are doing C/C++ and occasionally you need some python in your workflow, as in the conan package recipes themselves, or for some other tooling, you might find this functionality useful. Enjoy!</p>
:ET