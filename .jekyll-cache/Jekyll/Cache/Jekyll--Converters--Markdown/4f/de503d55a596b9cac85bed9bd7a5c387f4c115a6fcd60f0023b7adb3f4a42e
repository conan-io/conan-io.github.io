I"ìZ<p>You probably already had to develop a project where you needed to exchange information between
processes or even across different machines with different processor architectures. One
well-known technique in this scenario is <a href="https://en.wikipedia.org/wiki/
Serialization">serialization</a>, which is summarized in the translation of data structures or object state into a
format that can be stored and retrieved by the both sides.</p>

<p>In this blog post, we will discuss the <a href="https://developers.google.com/protocol-buffers">Protobuf</a>
(Protocol Buffers), a project that can extend more than a simple library for serialization. The
entire example presented here is available on <a href="https://github.com/conan-io/examples/tree/master/libraries/protobuf/serialization">Github</a>.</p>

<h2 id="what-is-protobuf">What is Protobuf?</h2>

<p>Protocol Buffers is an open source project under the BSD 3-Clause
<a href="https://github.com/protocolbuffers/protobuf/blob/master/LICENSE">license</a>, a popular one developed
by Google, to provide a language-neutral, platform-neutral and extensible mechanism for serializing
structured data. It supports many popular languages such as C++, C#, Dart, Go, Java and Python.
Although there are still other not official <a href="https://github.com/protocolbuffers/protobuf/
blob/master/docs/third_party.md">add-ons</a>, that support other languages, such as C. You can find the source
code on <a href="https://github.com/protocolbuffers/protobuf">Github</a>, where its popularity reaches almost
32K stars!</p>

<p>The neutral language used by Protobuf allows you to model messages in a structured format
through <strong>.proto</strong> files:</p>

<figure class="highlight"><pre><code class="language-proto" data-lang="proto"><span class="kd">message</span> <span class="nc">Person</span> <span class="p">{</span>
  <span class="k">required</span> <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">required</span> <span class="kt">int32</span> <span class="na">age</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">optional</span> <span class="kt">string</span> <span class="na">email</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>In the example above we use a structure that represents a person‚Äôs information, where it has
mandatory attributes, such as <em>name</em> and <em>age</em>, as well as having the optional <em>email</em> data.
Mandatory fields, as the name already says, must be filled when a new message is constructed,
otherwise, a <strong>runtime error</strong> will occur.</p>

<h2 id="but-why-not-xml">But Why not XML?</h2>

<p>But, why another language and serialization mechanism if we can use something already available
like XML? The answer is <a href="https://github.com/protocolbuffers/protobuf/blob/master/
docs/performance.md">performance</a>.</p>

<p>Protobuf has many advantages for serialization that go beyond the capacity of XML. It allows you
to create a simpler description than using XML. Even for small messages, when requiring multiple
nested messages, reading XML starts to get difficult for human eyes.</p>

<p>Another advantage is the size, as the Protobuf format is simplified, the files can reach 10 times
smaller compared to XML. But the great benefit is its speed, which can reach 100 times faster than
the standard XML serialization, all due to its optimized mechanism. In addition to size and speed,
Protobuf has a compiler capable of processing a .proto file to generate multiple supported
languages, unlike the traditional method where it is necessary to arrange the same structure in
multiple source files.</p>

<h2 id="that-sounds-good-but-how-do-i-use-it-in-real-life">That sounds good, but how do I use it in real life?</h2>

<p>So that we can illustrate the use of Protocol Buffers, we will exchange messages through different
architectures and opposite languages. We will compile a code in C++ for <em>armv7hf</em> architecture,
serialize an object to file, and retrieve through a Python script. An advantageous model for those
who need to exchange messages between opposing architectures through IPC techniques, even for
embedded systems.</p>

<p>For our example, we will use a message that has the reading of several sensors. The file
<strong>sensor.proto</strong>, which will represent the message, is described below:</p>

<figure class="highlight"><pre><code class="language-proto" data-lang="proto"><span class="na">syntax</span> <span class="o">=</span> <span class="s">"proto2"</span><span class="p">;</span>
<span class="kd">message</span> <span class="nc">Sensor</span> <span class="p">{</span>
  <span class="k">required</span> <span class="kt">string</span> <span class="na">name</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">required</span> <span class="kt">double</span> <span class="na">temperature</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">required</span> <span class="kt">int32</span> <span class="na">humidity</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="kd">enum</span> <span class="n">SwitchLevel</span> <span class="p">{</span>
    <span class="na">CLOSED</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="na">OPEN</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">required</span> <span class="n">SwitchLevel</span> <span class="na">door</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The variable <em>syntax</em> refers to the version of the Protobuf used, which can be <em>proto2</em> or <em>proto3</em>.
Versions 2 and 3 have important differences, but we will only address version 2 in this post. For
more information about version 3, see the
<a href="https://developers.google.com/protocol-buffers/docs/proto3">official documentation</a>.
In addition to the declared attributes, and previously highlighted there is the enumerator
<em>SwitchLevel</em>, which represents the state of a port. We could still include new messages, or even
lists for multiple ports, for example. For a complete description of the syntax used in proto
version 2, see the <a href="https://developers.google.com/protocol-buffers/docs/proto">language guide</a>.</p>

<p>The Protobuf serialization mechanism is given through the <code class="highlighter-rouge">protoc</code> application, this compiler
will parse the <code class="highlighter-rouge">.proto</code> file and will generate as output, source files according to the
configured language by its arguments, in this case, C++. You can also obtain more information
about, reading the section <a href="https://developers.google.com/protocol-buffers/
docs/reference/cpp-generated#invocation">compiler invocation</a>.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>protoc <span class="nt">--cpp_out</span><span class="o">=</span><span class="nb">.</span> sensor.proto</code></pre></figure>

<p>The <code class="highlighter-rouge">protoc</code> compiler will generate the <code class="highlighter-rouge">sensor.pb.h</code> and <code class="highlighter-rouge">sensor.pb.cc</code> files, respectively,
of which have the getters and setters needed to access the attributes, as well as methods for
serializing and parsing. The files work only as a stub, and it is necessary to include the headers
distributed by Protobuf. Without this compiler, we would have to describe all the steps of object
serialization in our code, and for any new change, it would be needed to update the C++ and Python
files.</p>

<p>Now that we have the stubs, we can implement an example to serialize the data collected by a sensor.
The file <code class="highlighter-rouge">main.cpp</code> will be described below:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include ‚Äúsensor.pb.h‚Äù
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Sensor</span> <span class="n">sensor</span><span class="p">;</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">"Laboratory"</span><span class="p">);</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">set_temperature</span><span class="p">(</span><span class="mf">23.4</span><span class="p">);</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">set_humidity</span><span class="p">(</span><span class="mi">68</span><span class="p">);</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">set_door</span><span class="p">(</span><span class="n">Sensor_SwitchLevel_OPEN</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>The Sensor object can be serialized through methods inherited from the <a href="https://
developers.google.com/protocol-buffers/docs/reference/cpp/google.protobuf.message">Message</a> class.
For example, we can serialize to a string by the <a href="https://developers.google.com/
protocol-buffers/docs/reference/cpp/google.protobuf.message_lite#MessageLite.SerializeAsString">SerializeAsString</a> method.</p>

<p>Note that this reconstruction can be performed by other languages also supported by Protobuf, in
addition to other architectures. In order for the transmission to occur through different processes,
it will be necessary to use <a href="https://en.wikipedia.org/wiki/Inter-process_communication">IPC</a>
techniques, for this, Google provides the <a href="https://grpc.io/">gRPC</a> project, a universal<a href="https://
en.wikipedia.org/wiki/Remote_procedure_call">RPC</a> framework, that supports Protobuf directly. However,
our intention in this post is just to talk about Protobuf, so we will use the only text file as a
means to exchange messages between processes:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#include &lt;fstream&gt;
#include ‚Äúsensor.pb.h‚Äù
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Sensor</span> <span class="n">sensor</span><span class="p">;</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">set_name</span><span class="p">(</span><span class="s">"Laboratory"</span><span class="p">);</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">set_temperature</span><span class="p">(</span><span class="mf">23.4</span><span class="p">);</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">set_humidity</span><span class="p">(</span><span class="mi">68</span><span class="p">);</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">set_door</span><span class="p">(</span><span class="n">Sensor_SwitchLevel_OPEN</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">ofs</span><span class="p">(</span><span class="s">"sensor.data"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="o">::</span><span class="n">out</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">ios_base</span><span class="o">::</span><span class="n">binary</span><span class="p">);</span>
    <span class="n">sensor</span><span class="p">.</span><span class="n">SerializeToOstream</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ofs</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>To perform serialization through a file, we use the <a href="https://developers.google.com/
protocol-buffers/docs/reference/cpp/google.protobuf.message#Message.SerializeToOstream.details">SerializeToOstream</a> method.</p>

<h2 id="building-the-project">Building the project</h2>

<p>For the next step, we will describe the actions for constructing the project by <a href="https://cmake.org/">CMake</a>:</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nb">cmake_minimum_required</span><span class="p">(</span>VERSION 3.1.2<span class="p">)</span>
<span class="nb">project</span><span class="p">(</span>sensor CXX<span class="p">)</span>

<span class="nb">include</span><span class="p">(</span><span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span>/conanbuildinfo.cmake<span class="p">)</span>
<span class="nf">conan_basic_setup</span><span class="p">(</span>TARGETS<span class="p">)</span>

<span class="nb">find_package</span><span class="p">(</span>Protobuf REQUIRED<span class="p">)</span>

<span class="nf">protobuf_generate_cpp</span><span class="p">(</span>PROTO_SRCS PROTO_HDRS sensor.proto<span class="p">)</span>
<span class="nb">add_executable</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> main.cc <span class="si">${</span><span class="nv">PROTO_SRCS</span><span class="si">}</span> <span class="si">${</span><span class="nv">PROTO_HDRS</span><span class="si">}</span><span class="p">)</span>
<span class="nb">target_link_libraries</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PUBLIC CONAN_PKG::protobuf<span class="p">)</span>
<span class="nb">target_include_directories</span><span class="p">(</span><span class="si">${</span><span class="nv">PROJECT_NAME</span><span class="si">}</span> PRIVATE <span class="si">${</span><span class="nv">CMAKE_BINARY_DIR</span><span class="si">}</span><span class="p">)</span></code></pre></figure>

<p>This recipe searches for the modules, libraries, and macros provided by the Protobuf project when
calling <a href="https://cmake.org/cmake/help/v3.1/command/find_package.html">find_package</a>. Once found and
loaded correctly, <code class="highlighter-rouge">protobuf_generate</code> macros will be available for use. The
<a href="https://cmake.org/cmake/help/v3.1/module/
FindProtobuf.html#command:protobuf_generate_cpp">protobuf_generate_cpp</a> function is responsible for executing the
<code class="highlighter-rouge">protoc</code> and populating the <code class="highlighter-rouge">PROTO_SRCS</code> and <code class="highlighter-rouge">PROTO_HDRS</code> variables with their generated
files. Without this functionality, you would need to manually add the <code class="highlighter-rouge">protoc</code> command and the
required arguments. The subsequent lines follow the most usual of CMake projects. Because the
generated files will be in the build directory, you need to include it by
<a href="https://cmake.org/cmake/help/v3.1/command/
target_include_directories.html">target_include_directories</a> so that <code class="highlighter-rouge">main.cc</code> can resolve <code class="highlighter-rouge">proto.pb.h</code>.</p>

<p>It is also possible to observe that we are using <a href="https://conan.io">Conan</a> to solve Protobuf as a
dependency. The <a href="https://docs.conan.io/en/latest/reference/generators/cmake.html#conan-basic-setup">conan_basic_setup</a>
function will be in charge of configuring all the necessary variables, besides generating the
target <code class="highlighter-rouge">CONAN_PKG::protobuf</code>.</p>

<p>In addition, you must also declare the
<a href="https://docs.conan.io/en/latest/reference/conanfile_txt.html">conanfile.txt</a> file with the
following dependencies:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">[build_requires]
protoc_installer/3.6.1@bincrafters/stable

[requires]
protobuf/3.6.1@bincrafters/stable

[generators]
cmake</code></pre></figure>

<p>Since Protobuf can be divided into two parts, the protoc installer, and the libraries, there are two
separate packages. Thus, it will be possible to install <code class="highlighter-rouge">protoc</code> for the same host architecture,
and libraries for a target architecture. As we are using CMake for this project, we need to declare
the CMake <a href="https://docs.conan.io/en/latest/integrations/cmake/cmake_generator.html">generator</a>.</p>

<p>Now just run the commands to build the project:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">mkdir </span>build
<span class="nb">cd </span>build
conan <span class="nb">install</span> ..
cmake .. <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release
cmake <span class="nt">--build</span> <span class="nb">.</span>
bin/sensor</code></pre></figure>

<p>So far so good, but how is it done in case of cross compilation? In this case, it will be necessary
to inform the compiler and the target platform:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash">conan <span class="nb">install</span> .. <span class="nt">-s</span> <span class="nb">arch</span><span class="o">=</span>armv7hf
cmake .. <span class="nt">-DCMAKE_BUILD_TYPE</span><span class="o">=</span>Release <span class="nt">-DCMAKE_CXX_COMPILER</span><span class="o">=</span>arm-linux-gnueabihf-g++
cmake <span class="nt">--build</span> .</code></pre></figure>

<p>In the above commands, we have installed only the prebuilt Protobuf libraries for <em>armv7hf</em>. The
<code class="highlighter-rouge">protoc</code> will only hold for <em>amd64</em> because it ignores arch, making use of only the host
architecture by <a href="https://docs.conan.io/en/latest/systems_cross_building/
cross_building.html#conan-settings">arch_build</a> in your profile. CMake needs to be informed which compiler will be used, so we
define it through <code class="highlighter-rouge">CMAKE_CXX_COMPILER</code>. Once ready, we can copy our application directly to the
target platform.</p>

<h2 id="parsing-with-python">Parsing with Python</h2>

<p>Now we get to the second step, read the file and retrieve the object using Python. For this, we will
only update the CMake script, so that it generates the C++ files and also the python stub:</p>

<figure class="highlight"><pre><code class="language-cmake" data-lang="cmake"><span class="nf">protobuf_generate_python</span><span class="p">(</span>PROTO_PYS sensor.proto<span class="p">)</span>
<span class="nb">add_custom_target</span><span class="p">(</span>proto_python ALL DEPENDS <span class="si">${</span><span class="nv">PROTO_PYS</span><span class="si">}</span><span class="p">)</span></code></pre></figure>

<p>The <code class="highlighter-rouge">protobuf_generate_python</code> function has the same goal as <code class="highlighter-rouge">protobuf_generate_cpp</code> but will
generate the file <code class="highlighter-rouge">sensor_pb2.py</code>. The <code class="highlighter-rouge">proto_python</code> virtual target was added to force CMake
to call the generator for Python.</p>

<p>The next step is to develop the script that will read the file with the serialized data and parse
it through the script generated in the previous step:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">from</span> <span class="nn">sensor_pb2</span> <span class="kn">import</span> <span class="n">Sensor</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"sensor.data"</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="nb">file</span><span class="p">:</span>
        <span class="n">content</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Retrieve Sensor object from sensor.data"</span><span class="p">)</span>
        <span class="n">sensor</span> <span class="o">=</span> <span class="n">Sensor</span><span class="p">()</span>
        <span class="n">sensor</span><span class="o">.</span><span class="n">ParseFromString</span><span class="p">(</span><span class="n">content</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"Sensor name: {sensor.name}"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"Sensor temperature: {sensor.temperature}"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="n">f</span><span class="s">"Sensor humidity: {sensor.humidity}"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Sensor door: {}"</span><span class="o">.</span><span class="nb">format</span><span class="p">(</span><span class="s">"Open"</span> <span class="k">if</span> <span class="n">sensor</span><span class="o">.</span><span class="n">temperature</span> <span class="k">else</span> <span class="s">"Closed"</span><span class="p">))</span></code></pre></figure>

<p>The script is fairly straightforward, just like the code in C++ and can be copied together with the
<code class="highlighter-rouge">sensor_pb2.py</code> file directly to the target platform.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Transfer data between processes, serializing objects or even storing data are techniques that are
widely used in all scenarios, but they require a lot of effort when implemented and are often not
the goal of the project under development. Serialization techniques can be solved through several
projects available, such as Protobuf, without having to delve into the low level required to
process all the data.</p>

<p>The success in using Protobuf is not only in serializing the data, but in the mechanism as a whole,
from the neutral language used, flexible and easy to understand, to the compiler with support for
multiple languages, and even integration with other products, such as the gRPC, which provides
direct communication between processes without much effort.</p>

<p>This post blog was a tutorial to demonstrate how tasks that could take up to hours to complete, with
library development, can be solved in a few steps, only using what is ready and without the need to
build from the sources.</p>

<p>Interested in knowing more or commenting on the subject? Please do not hesitate to open a new
<a href="https://github.com/conan-io/conan/issues">issue</a>.</p>
:ET