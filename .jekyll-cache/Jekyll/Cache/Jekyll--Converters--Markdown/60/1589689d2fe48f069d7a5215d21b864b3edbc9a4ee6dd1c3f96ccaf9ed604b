I"aM<p>Conan C/C++ package manager works with any build system to manage and share binaries, and to target any OS, compiler and architecture. This blog post provides a short tutorial that shows how you can use Conan to create, share and consume binary packages directly with a pure Visual Studio approach.</p>

<p>Microsoft has launched vcpkg, which is a package manager for Visual Studio based on CMake scripts. While it can be useful to retrieve and build the latest stable version of OSS libraries from sources, it  has some limitations when used as a dependency manager for user projects. One of them is the typically large size of projects, which requires managing pre-built binaries, since building from sources is not always feasible. Another inconvenience is that installing different versions of the same package simultaneously requires to manage different instances of vcpkg.</p>

<p>In the course of this tutorial you will see that Conan can be used as a package manager for both pure Visual Studio and hybrid stacks. You will also see that when using Conan you don’t have to build from sources; you can also manage and share binaries for as many configurations as needed.</p>

<p>The main steps of this tutorial are:</p>

<ol>
  <li>Clone and build an example “Hello World” Visual Studio project</li>
  <li>Create conan packages from the existing project</li>
  <li>Create multiple package binaries for different configurations</li>
  <li>Upload packages to your Conan server or JFrog Artifactory</li>
  <li>Reuse existing packages and binaries in a consumer Visual Studio project</li>
  <li>Create conan packages from the consumer project</li>
</ol>

<h1 id="a-hello-world-visual-studio-project">A “Hello World” Visual Studio project</h1>
<p>Start by cloning the existing example repository. It contains  a simple “Hello World” library and the corresponding application:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/memsharded/hello_vs
<span class="nv">$ </span><span class="nb">cd </span>hello_vs
</code></pre></div></div>

<p>It contains a <code class="highlighter-rouge">src</code> folder with the source code and a <code class="highlighter-rouge">build</code> folder with a Visual Studio 2015 solution containing 2 projects: a static library called “HelloLib” and an application called “Greet”. Open the Visual Studio solution:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>build<span class="se">\H</span>elloLib<span class="se">\H</span>elloLib.sln
</code></pre></div></div>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2017_05_11/visual_studio.png" align="center" />
</p>

<p>Set <code class="highlighter-rouge">Greet</code> as the startup project (Right-click <code class="highlighter-rouge">Greet</code> and select <code class="highlighter-rouge">Set as Startup Project</code>) Then build and run the app with Ctrl+F5. (Debug -&gt; Start Without Debugging). Note that since the <code class="highlighter-rouge">hello.cpp</code> file contains an <code class="highlighter-rouge">#ifdef _DEBUG</code> to switch between debug and release messages, you can switch to Release mode and obtain a different output.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>Hello World Debug!
<span class="c"># Switch IDE to Release mode, build and run again</span>
<span class="nv">$ </span>Hello World Release!
</code></pre></div></div>

<h1 id="creating-conan-packages">Creating conan packages</h1>

<p>The cloned repo already contains a Conan recipe:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">HelloConan</span><span class="p">(</span><span class="n">ConanFile</span><span class="p">):</span>
    <span class="n">name</span> <span class="o">=</span> <span class="s">"Hello"</span>
    <span class="n">version</span> <span class="o">=</span> <span class="s">"0.1"</span>
    <span class="n">license</span> <span class="o">=</span> <span class="s">"MIT"</span>
    <span class="n">url</span> <span class="o">=</span> <span class="s">"https://github.com/memsharded/hello_vs"</span>
    <span class="n">settings</span> <span class="o">=</span> <span class="s">"os"</span><span class="p">,</span> <span class="s">"compiler"</span><span class="p">,</span> <span class="s">"build_type"</span><span class="p">,</span> <span class="s">"arch"</span>
    <span class="n">exports_sources</span> <span class="o">=</span> <span class="s">"src/*"</span><span class="p">,</span> <span class="s">"build/*"</span>

    <span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">cmd</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">msvc_build_command</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span> <span class="s">"build/HelloLib/HelloLib.sln"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">package</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">"*.h"</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="s">"include"</span><span class="p">,</span> <span class="n">src</span><span class="o">=</span><span class="s">"src"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s">"*.lib"</span><span class="p">,</span> <span class="n">dst</span><span class="o">=</span><span class="s">"lib"</span><span class="p">,</span> <span class="n">keep_path</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">package_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cpp_info</span><span class="o">.</span><span class="n">libs</span> <span class="o">=</span> <span class="p">[</span><span class="s">"HelloLib"</span><span class="p">]</span>
</code></pre></div></div>

<p>This recipe uses the <code class="highlighter-rouge">msvc_build_command()</code> function to get a command string containing the commands required to build the application with the correct configuration.</p>

<p>The recipe also contains a <code class="highlighter-rouge">test_package</code> folder with a simple example consuming application. In this example, the consuming application uses CMake to build, but it could also have used Visual Studio. We use CMake because it is the default generated with <code class="highlighter-rouge">conan new</code>, and to show that packages created from Visual Studio projects can also be consumed by other build systems such as CMake. This shows how Conan decouples the build system, which can help, for example, in a progressive migration to a new build system.</p>

<p>Now that we’re ready  to create a package, we recommend closing  the Visual Studio IDE, cleaning the temporary build files from Visual Studio to avoid problems, and then creating and testing the package (here it is using system defaults, assuming they are Visual Studio 14, Release, x86_64):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># close VS</span>
<span class="nv">$ </span>git clean <span class="nt">-xdf</span>
<span class="nv">$ </span>conan test_package
...
<span class="o">&gt;</span> Hello World Release!
</code></pre></div></div>

<p>Instead of closing the IDE and running <code class="highlighter-rouge">git clean</code>, we could also configure a smarter filter in <code class="highlighter-rouge">exports_sources</code> field, so temporary build files are not exported into the recipe.</p>

<h1 id="creating-different-binaries-for-different-configurations">Creating different binaries for different configurations</h1>

<p>This process can be repeated to create and test packages for different configurations:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan test_package <span class="nt">-s</span> <span class="nb">arch</span><span class="o">=</span>x86
<span class="nv">$ </span>conan test_package <span class="nt">-s</span> <span class="nv">compiler</span><span class="o">=</span><span class="s2">"Visual Studio"</span> <span class="nt">-s</span> compiler.runtime<span class="o">=</span>MDd <span class="nt">-s</span> <span class="nv">build_type</span><span class="o">=</span>Debug
<span class="nv">$ </span>conan test_package <span class="nt">-s</span> <span class="nv">compiler</span><span class="o">=</span><span class="s2">"Visual Studio"</span> <span class="nt">-s</span> compiler.runtime<span class="o">=</span>MDd <span class="nt">-s</span> <span class="nv">build_type</span><span class="o">=</span>Debug <span class="nt">-s</span> <span class="nb">arch</span><span class="o">=</span>x86
</code></pre></div></div>

<p>You can list the different package binaries that were created:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan search Hello/0.1@memsharded/testing
</code></pre></div></div>

<h1 id="uploading-binaries">Uploading binaries</h1>

<p>Once you have created a package locally, you can upload it to a Conan remote server. If you created it with the original username “memsharded”, as from the git clone, you might want to do a <code class="highlighter-rouge">conan copy</code> to put them on your own username. Of course, you can also edit the recipes or set the environment variable <code class="highlighter-rouge">CONAN_USERNAME</code> to define your own username.</p>

<p>Another alternative is to configure the permissions in the remote, to allow uploading packages with different usernames. Artifactory will allow it, but by default, conan_server doesn’t; permissions must be expressly provided in the <code class="highlighter-rouge">[write_permissions]</code> section of <code class="highlighter-rouge">server.conf</code>.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan upload Hello/0.1@memsharded/testing <span class="nt">--all</span> <span class="nt">-r</span><span class="o">=</span>myserver
</code></pre></div></div>

<h1 id="reusing-packages">Reusing packages</h1>

<p>To use existing packages directly from Visual Studio, Conan provides the <code class="highlighter-rouge">visual_studio</code> generator. Let’s clone an existing “Chat” project, consisting of a “ChatLib” static library that makes use of the previous “Hello World” package, and a “MyChat” application which calls the “ChatLib” library function.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/memsharded/chat_vs
<span class="nv">$ </span><span class="nb">cd </span>chat_vs
</code></pre></div></div>

<p>As in the previous example, the repository contains a Visual Studio solution in the <code class="highlighter-rouge">build</code> folder. But if you try to open it, it will fail to load. This is because it expects to find a file with the required information about dependencies, so you first have to obtain that file . Just run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan <span class="nb">install</span> <span class="nb">.</span>
</code></pre></div></div>

<p>You will see that it created two files: a <code class="highlighter-rouge">conaninfo.txt</code> file containing the current configuration of dependencies, and a <code class="highlighter-rouge">conanbuildinfo.props</code> file containing the Visual Studio properties (such as  <code class="highlighter-rouge">&lt;AdditionalIncludeDirectories&gt;</code>), so it is able to find the installed dependencies.</p>

<p>Now you can open the IDE and build and run the app (by the way, all the chat function does is call the <code class="highlighter-rouge">hello()</code> function two or three times depending on the build type):</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span> build<span class="se">\C</span>hatLib<span class="se">\C</span>hatLib.sln
<span class="c"># Switch to Release</span>
<span class="c"># MyChat -&gt; Set as Startup Project</span>
<span class="c"># Ctrl + F5 (Debug -&gt; Run without debugging)</span>
<span class="o">&gt;</span> Hello World Release!
<span class="o">&gt;</span> Hello World Release!
</code></pre></div></div>

<p>If you wish to link with the debug version of the Hello package, just install it and change the IDE build type:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan <span class="nb">install</span> <span class="nb">.</span> <span class="nt">-s</span> <span class="nv">build_type</span><span class="o">=</span>Debug <span class="nt">-s</span> <span class="nv">compiler</span><span class="o">=</span><span class="s2">"Visual Studio"</span> <span class="nt">-s</span> compiler.runtime<span class="o">=</span>MDd
<span class="c"># Switch to Debug</span>
<span class="c"># Ctrl + F5 (Debug -&gt; Run without debugging)</span>
<span class="o">&gt;</span> Hello World Debug!
<span class="o">&gt;</span> Hello World Debug!
<span class="o">&gt;</span> Hello World Debug!
</code></pre></div></div>

<h1 id="creating-packages-from-the-consumer-project">Creating packages from the consumer project</h1>

<p>Now you can close the IDE and clean the temporary files:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># close VS IDE</span>
<span class="nv">$ </span>git clean <span class="nt">-xdf</span>
</code></pre></div></div>

<p>Again, there is a <code class="highlighter-rouge">conanfile.py</code> package recipe in the repository together with a <code class="highlighter-rouge">test_package</code>. The recipe is almost identical to the previous one, but with two minor differences:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">requires</span> <span class="o">=</span> <span class="s">"Hello/0.1@memsharded/testing"</span>
<span class="o">...</span>
<span class="n">generators</span> <span class="o">=</span> <span class="s">"visual_studio"</span>
</code></pre></div></div>

<p>This will allow us to create and test the package of the “ChatLib” library:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>conan test_package
...
<span class="o">&gt;</span> Hello World Release!
<span class="o">&gt;</span> Hello World Release!
</code></pre></div></div>

<p>You can also repeat the process for different build types and architectures, as above. The binary packages for the ChatLib library can also be uploaded and shared.</p>

<h1 id="other-configurations">Other configurations</h1>

<p>The above example works “as is” for VS2017, because VS supports upgrading from previous versions. The <code class="highlighter-rouge">tools.msvc_build_command()</code> already implements such functionality, so you can build and test packages with VS2017. The only requirement is to define the <code class="highlighter-rouge">VS150COMNTOOLS</code> environment variable because VS2017 doesn’t define it, and it is needed to find the tools:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># maybe better done system-wide after VS2017 installation</span>
<span class="nv">$ </span><span class="nb">set </span>VS150COMNTOOLS C:/Program Files <span class="o">(</span>x86<span class="o">)</span>/Microsoft Visual Studio/2017/Community/Common7/Tools
<span class="nv">$ </span>conan test_package <span class="nt">-s</span> <span class="nv">compiler</span><span class="o">=</span><span class="s2">"Visual Studio"</span> <span class="nt">-s</span> compiler.version<span class="o">=</span>15
</code></pre></div></div>

<p>If needed,  you can also build for older versions of Visual Studio. In that case, you would probably have different solution projects inside your build folder. Then’ the recipe only has to select the correct one, something like:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="c1"># assuming HelloLibVS12, HelloLibVS14 subfolders
</span>    <span class="n">sln_file</span> <span class="o">=</span> <span class="s">"build/HelloLibVS</span><span class="si">%</span><span class="s">s/HelloLib.sln"</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">compiler</span><span class="o">.</span><span class="n">version</span>
    <span class="n">cmd</span> <span class="o">=</span> <span class="n">tools</span><span class="o">.</span><span class="n">msvc_build_command</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span> <span class="n">sln_file</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">cmd</span><span class="p">)</span>
</code></pre></div></div>

<h1 id="conclusions">Conclusions</h1>

<p>First, a note. Currently, <code class="highlighter-rouge">visual_studio</code> is a single-configuration generator (i.e., packages contain either debug or release artifacts, the generally recommended approach). It does not support multi-config packages (i.e., those containing both debug and release artifacts). If you need this feature, please report and provide feedback by submitting an issue in <a href="https://github.com/conan-io/conan">github</a>).</p>

<p>Microsoft Windows and Visual Studio have always been first class citizens in Conan. There are many OSS tools created mainly for “nix” like environments, and support for Windows comes later as an afterthought which sometimes requires inconvenient workarounds. While the Conan documentation and examples largely use CMake for convenience, it is not a requirement. This blog post shows that Conan can be used as a package manager for both pure Visual Studio and hybrid stacks that use other build systems. And not only building from sources, but also for managing and sharing binaries for as many configurations as needed in Conan remote servers (Artifactory or conan_server).</p>

<p>Any feedback? Please tell us in <a href="https://twitter.com/conan_io">@conan_io</a> or email: info@conan.io</p>
:ET