I"Î6<p>We all know the importance of Continuous Integration while developing software: running unit or integration tests, supporting different
platforms/devices, supporting different versions of a compiler or library and having the latest version of the software always ready for a
new release are some of the reasons.</p>

<p>Developing a final application in the same platform where it will be finally deployed is fine and makes things easier, as you have the setup
done, all the tooling needed is installed and you could at some point even test in your machine simulating the final deploy target for the
application.</p>

<p>Programming for embedded devices comes into place that is a horse of a different color. Normally you would have to setup a kind of fixed
environment with the variables needed to  cross-compile, the cross-compiler and toolchain ready to be used. This does not sound very painful
and Conan has already some features to help with such setup:
<a href="http://docs.conan.io/en/latest/devtools/create_installer_packages.html">installer packages</a>,
<a href="http://docs.conan.io/en/latest/howtos/python_code_reuse.html">python packages to share scripts</a>, the
<a href="http://docs.conan.io/en/latest/reference/generators/virtualenv.html">virtualenv generator</a> and
<a href="http://docs.conan.io/en/latest/reference/commands/consumer/config.html#conan-config-install">conan config install</a>.</p>

<p>However, when you start to support different devices it is quite easy to mess up you environment configuration and you can waste a lot of
time checking everything is setup correctly. To help with this we recently published a
<a href="http://docs.conan.io/en/latest/howtos/run_conan_in_docker.html">how-to in our documentation</a> showing a good range of Docker images 
ready to cross build.</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-04-25/title.png" align="center" width="600" alt="Continuous integration for C/C++ embedded devices with Jenkins, Docker and Conan" />
</p>

<p>In this post we will show you how to use this images to setup a continuous integration job in Jenkins to cross build for ARM devices and
create a final application.</p>

<h2 id="the-application-as-a-conan-package">The application as a Conan package</h2>

<p>The application we will be building is a simple blink using the WiringPi library to interface the GPIO pins of a Raspberry Pi.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;iostream&gt;

#ifdef WIRINGPI
    #include &lt;wiringPi.h&gt;
#endif

int main (void)
{
    #ifdef WIRINGPI
        wiringPiSetup();
        pinMode(0, OUTPUT);
    #endif

    while(1)
    {
        std::cout &lt;&lt; "HIGH" &lt;&lt; std::endl;
        #ifdef WIRINGPI
            digitalWrite(0, HIGH);
            delay(500);
        #endif

        std::cout &lt;&lt; "LOW" &lt;&lt; std::endl;
        #ifdef WIRINGPI
            digitalWrite(0, LOW);
            delay(500);
        #endif
    }
    return 0;
}
</code></pre></div></div>

<p>As you can see it is a quite simple application with some extra defines to avoid the WirignPi library in case it is not needed. We recently
included <a href="https://bintray.com/conan-community/conan/wiringpi%3Aconan">wiringpi/2.46@conan/stable</a> in conan-center so we will use it as an
optional dependency.</p>

<p>Here you can see the full project: https://github.com/danimtb/conan-blink-app</p>

<p>The recipe has some settings when using the armv7 configuration:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from conans import ConanFile, CMake


class BlinkAppConan(ConanFile):
    name = "BlinkApp"
    version = "0.1"
    license = "MIT"
    description = "Blink application"
    settings = "os", "compiler", "build_type", "arch"
    url = "https://github.com/conan-community/conan-blink-app.git"
    exports_sources = "CMakeLists.txt", "main.cpp", "LICENSE"
    generators = "cmake"

    def build(self):
        cmake = CMake(self)
        if self.settings.arch == "armv7":
            cmake.definitions["WIRINGPI"] = True
        cmake.configure()
        cmake.build()

    def package(self):
        self.copy("blinkapp", src="bin", dst="bin")

    def requirements(self):
        if self.settings.arch == "armv7":
            self.requires("wiringpi/2.46@conan/stable")

    def deploy(self):
        self.copy("blinkapp", src="bin", dst="bin")
</code></pre></div></div>

<p>The recipe is quite simple and there are just few points to remark:</p>

<ul>
  <li>There is a conditional in <code class="highlighter-rouge">build()</code> and <code class="highlighter-rouge">requirements()</code>: This is to manage the optional dependency of WiringPi as said before.</li>
  <li><code class="highlighter-rouge">package()</code> gets the application in order to make a package of it.</li>
  <li>The <code class="highlighter-rouge">deploy()</code> is there to <a href="https://docs.conan.io/en/latest/devtools/running_packages.html#deployable-packages">make the app deployable</a>
from the command line: <code class="highlighter-rouge">conan install BlinkApp/0.1@danimtb/stable</code></li>
</ul>

<h2 id="setting-up-jenkins-and-artifactory-in-the-ci-machine">Setting up Jenkins and Artifactory in the CI machine</h2>

<p>For this post I am using a Linux machine where Jenkins together with Docker and Artifactory will be running. These are the things you will
need:</p>

<ul>
  <li>
    <p><strong>Jenkins</strong>: We will use Jenkins for the automation of Continuous Integration jobs.</p>

    <p>I used these steps to install it:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -
$ sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'
$ sudo apt-get update
$ sudo apt-get install jenkins
</code></pre></div>    </div>

    <p>Check the (installation steps)[https://jenkins.io/doc/book/installing/] for other platforms.</p>
  </li>
  <li>
    <p><strong>Artifactory</strong>: We will use it as our binary repository to retrieve and upload the Conan packages.</p>

    <p>I chose the <a href="http://blog.conan.io/2018/03/27/Announcing-JFrog-Artifactory-Community-Edition-C-C++.html">latest release of Artifactory Community Edition for C/C++</a> and went for the zip installation:</p>

    <ul>
      <li>Download zip: https://www.conan.io/downloads.html</li>
      <li>Set <code class="highlighter-rouge">JAVA_HOME=/usr/lib/jvm/default-java</code></li>
      <li>Launch Artifactory: <code class="highlighter-rouge">bin/artifactory.sh</code></li>
    </ul>

    <p>The Artifactory instance should be accessible at: <code class="highlighter-rouge">localhost:8081/artifactory</code>. Just after the configuration steps create a Conan
repository called <strong>conan-local</strong>.</p>
  </li>
  <li>
    <p><strong>Jenkins Artifactory Plug-in</strong>:</p>

    <p>Of course, if you are using Jenkins and Artifactory you should take advantage of this
<a href="https://www.jfrog.com/confluence/display/RTF/Jenkins+Artifactory+Plug-in">plug-in</a>. Makes the integration much easier in the case of
Conan to configure the remotes and credentials and to upload the metadata of the build.</p>

    <p>Follow the installation steps and configure the plugin with your Artifactory credentials:</p>

    <p class="centered">
  <img src="http://localhost:4000/assets/post_images/2018-04-25/jenkins-artifactory-plugin.png" align="center" width="600" alt="Configuration of the Jenkins Artifactory Plug-in" />
</p>
  </li>
  <li>
    <p><strong>Docker</strong>: Of course, we will be using Docker so we need to have it installed in the CI machine too.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ apt-get install docker-ee
$ Docker -v
&gt; Docker version 1.13.1, build 092cba3
</code></pre></div>    </div>

    <p>Check the <a href="https://docs.docker.com/install/">installation steps</a> for other platforms.</p>
  </li>
</ul>

<h2 id="creating-the-jenkins-pipeline">Creating the Jenkins pipeline</h2>

<p>There is related information on the web about how to run Jenkins inside a docker container or how to use the Docker plugin to launch builds.
However there is not much about how to run a local build inside a Docker container with Jenkins.</p>

<p>This should not be too much complicated if you use a command line script for the build but it is so much better to use the pipeline syntax
to control the stages.</p>

<p>Here you can see the <em>Jenkinsfile</em> to create this application:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def artifactory_name = "artifactory_local"
def artifactory_repo = "conan-local"
String docker_image = 'lasote/conangcc6-armv7'

node {
    docker.image(docker_image).inside('-v /tmp/:/tmp/ -v /home/danimtb/:/home/conan/danimtb/ --net=host') { 
        def server = Artifactory.server artifactory_name
        def client = Artifactory.newConanClient() 
        def serverName = client.remote.add server: server, repo: artifactory_repo

        stage("Get project") {
            checkout scm
        }

        stage("Get dependencies and create app") {
            String strCommand = "create . danimtb/stable -pr /home/conan/.conan/profiles/default"
            client.run(command: strCommand )
        }

        stage("Upload packages") {
            String command = "upload BlinkApp* --all -r ${serverName} --confirm"
            def b = client.run(command: command)
            b.env.collect()
            server.publishBuildInfo b
        }
    }
}
</code></pre></div></div>

<p>As you can see in the <em>Jenkinsfile</em> we are setting up the name or our Artifactory instance already set up in the Jenkins Artifactory Plug-in
and the Conan repository name. We donât need to configure any credentials or use environment variable <code class="highlighter-rouge">CONAN_PASSWORD</code>.</p>

<p>The Docker image we are using in this case is <code class="highlighter-rouge">lasote/conangcc6-armv7</code> and it will run the build with some directory and network mappings:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker.image(docker_image).inside('-v /tmp/:/tmp/ -v /home/danimtb/:/home/conan/danimtb/ --net=host')
</code></pre></div></div>

<ul>
  <li><code class="highlighter-rouge">/tmp/:/tmp/</code>: We will map the temp directory here as it is the directory Jenkins use to store the files and metadata of the build.
This is useful to keep that information so that it does not get destroyed after the Docker image is stopped.</li>
  <li><code class="highlighter-rouge">/home/danimtb/:/home/conan/danimtb/</code>: This is just a dumb mapping of a local directory to allow the clone of the SCM just because I was using a local     git repository in this case.</li>
  <li><code class="highlighter-rouge">--net=host</code>: This maps the network of the container to the network of the host. This is needed to upload the packages to Artifactory.</li>
</ul>

<p>Those images are prepared with a profile inside ready to target the architecture:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>String strCommand = "create . danimtb/stable -pr /home/conan/.conan/profiles/default"
client.run(command: strCommand )
</code></pre></div></div>

<h2 id="triggering-a-build">Triggering a build</h2>

<p>The trigger of the build can be done with normal Jenkins configuration. I used a self-contained one with a local git repository and a
multibranch job. This way Jenkins can check the repository for changes and trigger the job.</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-04-25/artifactory.png" align="center" width="600" alt="BlinkApp package for armv7 uploaded to Artifactory" />
</p>

<p>The multibranch approach has also other benefits, as you can customize your <em>Jenkinsfile</em> in case you have a branch for testing and another
one stable, as you can change the <code class="highlighter-rouge">user/channel</code> provided in the <code class="highlighter-rouge">conan create</code> step.</p>

<p>Any other approach is also valid, for example, you could trigger the build with a <a href="https://support.cloudbees.com/hc/en-us/articles/224543927-GitHub-Integration-Webhooks">GitHub hook</a> and have the same behavior as if it was a CI build
running in Travis CI or AppVeyor.</p>

<p>With the package of the final application uploaded, you can test the application in final devices with a simple
<code class="highlighter-rouge">conan install BlinkApp/0.1@danimtb/stable</code> taking advantage of the <code class="highlighter-rouge">deploy()</code> and use it for testing purposes like hardware-in-the-loop
or create installers/tarballs to deliver the app and its resources.</p>

<h2 id="conclusions">Conclusions</h2>

<p>As you can see, the most complicated part of this is configuring Jenkins and Artifactory to run the complete example. However, if you
already have an instance of each one up and running this should be very straight forward.</p>

<p>This is just an example of what kind of things you can do taking advantage of Docker and Jenkins and one way it can be used to automate the
package creation. This could be extended to the creation of libraries, bumping of package versions of a of downstream dependencies whenever
there is a new release upstream, running package testsâ¦</p>

<p>You can also create your own Docker image with the tools you want. Check our
<a href="https://github.com/conan-io/conan-docker-tools">conan-docker-tools repository</a> to take some inspiration from the <em>Dockerfiles</em>.</p>

<p>Hope you found this example useful to set up a CI machine with everything needed to start automating the creation of your Conan packages!</p>
:ET