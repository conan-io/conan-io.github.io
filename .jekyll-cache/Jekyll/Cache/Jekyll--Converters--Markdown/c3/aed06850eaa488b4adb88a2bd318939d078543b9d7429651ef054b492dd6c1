I" n<p>There are many embedded Linux distributions ready for use with good functionality, but at the cost of image size, some images can reach 4GB. Sometimes we want embedded systems that support Linux with only the minimum packages needed for our system, such as running a small FTP server with no graphical interface.</p>

<p>To fulfill the object of getting a custom image, we can automate and facilitate building a distro through some build tools for embedded Linux-based systems. Some existing ones today include <a href="https://www.yoctoproject.org/">Yocto</a> and <a href="https://buildroot.org/">Buildroot</a>, which are open source projects.</p>

<p>In this blog post we will comment on using Buildroot and how we can use it to create a customized image for <a href="https://www.raspberrypi.org/products/raspberry-pi-3-model-b/">RaspberryPi3</a>. The entire example is available <a href="https://github.com/conan-community/buildroot">here</a>.</p>

<h2 id="buildroot">Buildroot</h2>

<p><img src="http://localhost:4000/assets/post_images/2019-08-27/conan-buildroot-logo.png" style="width:200px;display: block;margin: 0 auto;" /></p>

<p>Buildroot is a tool for automating the creation of Embedded Linux distributions. It builds the code for the architecture of the board so it was set up, all through an overview of Makefiles. In addition to being open-source, it is licensed under <a href="https://spdx.org/licenses/GPL-2.0-or-later.html">GPL-2.0-or-later</a>.</p>

<h2 id="how-to-install">How to Install</h2>

<p>Before starting Buildroot installation, letâ€™s assume you have a Linux environment ready for building C projects, as well as tools for git, svn, and rsync.</p>

<p>You can get more information about the requirements through the official Buildroot <a href="https://buildroot.org/downloads/manual/manual.html">documentation</a>.</p>

<p>In order to install Buildroot, we will clone the repository through Github:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>git clone https://github.com/buildroot/buildroot.git buildroot</code></pre></figure>

<h2 id="analyzing-the-buildroot">Analyzing the Buildroot</h2>

<p>Once inside the Buildroot directory, we will have the following tree:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">buildroot/
|
â”œâ”€â”€ arch
â”œâ”€â”€ board
â”œâ”€â”€ boot
â”œâ”€â”€ configs
â”œâ”€â”€ docs
â”œâ”€â”€ linux
â”œâ”€â”€ package
â”œâ”€â”€ support
â”œâ”€â”€ system
â”œâ”€â”€ toolchain
â””â”€â”€ utils</code></pre></figure>

<p>Each directory holds a set of files needed to set up a part of the build. Here we can highlight:</p>

<ul>
  <li>board: Contains files for target board mapping and configuration, such as flash memory address and device tree files;</li>
  <li>configs: Contains a series of pre-set configurations to automate which packages and properties should be added to the embedded image;</li>
  <li>packages: Contains all official packages available so far for Buildroot. We are not limited to these packages only, Buildroot allows we to create new custom packages.</li>
</ul>

<p>We will give more focus to package folder, as our main interest will be to customize the packages installed in our image.</p>

<p>As an example, letâ€™s look at the <a href="https://github.com/fmtlib/fmt">fmt</a> package, which consists of 3 files:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">package/fmt/
|
â”œâ”€â”€ Config.in
â”œâ”€â”€ fmt.hash
â””â”€â”€ fmt.mk</code></pre></figure>

<p><em>Config.in</em> is the package description to be used for Buildroot configuration, it is responsible for maintaining the information for the user interface when choosing which packages to build. It also contains the package dependencies.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">config BR2_PACKAGE_FMT
    bool "fmt"
    depends on BR2_INSTALL_LIBSTDCPP
    depends on BR2_USE_WCHAR
    help
      fmt is an open-source formatting library for C++. It can be
      used as a safe alternative to printf or as a fast alternative
      to IOStreams.

      https://fmt.dev/latest/index.html</code></pre></figure>

<p>The <em>fmt.mk</em> file is the Makefile recipe for setting up, building, and installing the library.</p>

<figure class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">FMT_VERSION</span> <span class="o">=</span> 5.3.0
<span class="nv">FMT_SITE</span> <span class="o">=</span> <span class="nf">$(</span><span class="nb">call</span> github,fmtlib,fmt,<span class="nv">$(FMT_VERSION)</span><span class="nf">)</span>
<span class="nv">FMT_LICENSE</span> <span class="o">=</span> BSD-2-Clause
<span class="nv">FMT_LICENSE_FILES</span> <span class="o">=</span> LICENSE.rst
<span class="nv">FMT_INSTALL_STAGING</span> <span class="o">=</span> YES

<span class="nv">FMT_CONF_OPTS</span> <span class="o">=</span> <span class="se">\</span>
    <span class="nt">-DHAVE_OPEN</span><span class="o">=</span>ON <span class="se">\</span>
    <span class="nt">-DFMT_INSTALL</span><span class="o">=</span>ON <span class="se">\</span>
    <span class="nt">-DFMT_TEST</span><span class="o">=</span>OFF

<span class="err">$(eval</span> <span class="err">$(cmake-package))</span></code></pre></figure>

<p>This file stores default properties for all other packages, such as its version, site from which to download the source code, software license name, and where to find that license file.</p>

<p>Here you can see that at the end a module called <strong>cmake-package</strong> is invoked. This module is responsible for handling projects using <a href="https://cmake.org/">CMake</a>, where it will execute all necessary commands, from configuration to installation of artifacts. This modularization allows for a higher level of automation, otherwise it would be necessary to describe all CMake commands for each package.</p>

<p>The last and not the least file, <em>fmt.hash</em> holds the checksum of the downloaded file directly from the site.</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">sha256 defa24a9af4c622a7134076602070b45721a43c51598c8456ec6f2c4dbb51c89  fmt-5.3.0.tar.gz
sha256 560d39617dfb4b4e4088597291a070ed6c3a8d67668114ed475c673430c3e49a  LICENSE.rst</code></pre></figure>

<p>Although we are using SHA-256, Buildroot is able to support other formats like SHA-1 and MD5. The checksum is automatically verified by Buildroot during package download. If the value found is not the same as described, an error will be raised.</p>

<h2 id="configuring-the-custom-image">Configuring the Custom Image</h2>

<p>As our target platform is RaspberryPi3, Buildroot offers a pre-configured file for this board, which is located within the configs directory.</p>

<p>To ask Buildroot that we want to build our configuration from RaspberryPi3, we should use the following command:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make raspberrypi3_defconfig</code></pre></figure>

<p>Once executed, this command will generate the file <em>.config</em>, which contains all the packages, kernel, toolchain and properties needed for our image. To add new packages or edit existing ones, we need to manipulate this file, but this is not very automated and can result in a number of errors during the construction. Thatâ€™s why Buildroot has more user-friendly interfaces, where you can customize your final configuration, and automatically resolve dependencies. There are different formats for this interface you can try some of them:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make config
<span class="nv">$ </span>make menuconfig
<span class="nv">$ </span>make gconfig
<span class="nv">$ </span>make xconfig</code></pre></figure>

<p>During this example we will use <em>menuconfig</em>, as it has a minimal graphical interface and does not require other system dependencies like Qt.</p>

<p>After executing the configuration command, we will have the following output:</p>

<p><img src="http://localhost:4000/assets/post_images/2019-08-27/conan-buildroot-menuconfig.png" style="display: block;margin: 0 auto;" /></p>

<p>As we had already detailed the <em>fmt</em> library before, we will include it in our image, so we have to navigate thought the menu in the following way:</p>

<p><code class="highlighter-rouge">Target Packages -&gt; Libraries -&gt; Text and terminal handling -&gt; fmt</code></p>

<p>To get more information about the package, you can enter <strong>?</strong>. It will show the same content as we had seen in the <em>Config.in</em> file.
Once selected, we can save the current setting through the panel and exit by pressing <em>ESC</em>.</p>

<h2 id="building-the-image">Building the Image</h2>

<p>Once setup is ready, we can proceed to the longest step in this tutorial, building the image. Although the build is just a command, Buildroot will have to download all the sources that are present in the configuration file, build from sources and finally generate a custom image. To start the build process just run:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span>make</code></pre></figure>

<p>From now, Buildroot will take care of the entire build process, which may take a few hours the first time. For future builds, the cache may be reused which will down the build time to a few minutes.</p>

<h2 id="using-conan-for-buildroot-builds">Using Conan for Buildroot builds</h2>

<p>Although Buildroot can accept new packages through its package structure, the build process is still a bit long, it could take few hours on the first time. But what if this process could be reduced to just a few minutes by downloading pre-built packages? Let us see some features and aspects from Conan which are related to our scenario:</p>

<ul>
  <li>Able to provide a unified view of all binaries for all platforms and configurations, not only buildroot;</li>
  <li>Developers might develop fast, test locally with native binaries in their Linux boxes;</li>
  <li>Faster builds, thanks to reusing binaries, not only for development but for production and releases;</li>
  <li>Best DevOps practices, avoiding rebuilding binaries from sources more than once.</li>
</ul>

<p>Before introducing Conan into Buildroot, we need to understand how the structure of scripts that collaborate with buildroot for package building:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">ls </span>package/<span class="k">*</span>.mk
package/doc-asciidoc.mk   package/pkg-cmake.mk  package/pkg-download.mk  package/pkg-golang.mk
...</code></pre></figure>

<p>This list of Makefiles are responsible for executing the build process for each given package. Returning to the recipe example for the ZLib library, we have the following section:</p>

<figure class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="err">$(eval</span> <span class="err">$(cmake-package))</span></code></pre></figure>

<p>This line tells us that the <code class="highlighter-rouge">pkg-cmake.mk</code> script will be used to build the <em>ZLib</em> project. In the case of integrating Conan we will have to build a new script with the commands responsible for downloading the desired packages, according to the configuration given by Buildroot, and copy the artifacts to their proper locations.</p>

<h2 id="integrating-conan-with-buildroot">Integrating Conan with Buildroot</h2>

<p>Letâ€™s create a new file called <strong>pkg-conan.mk</strong> in the <code class="highlighter-rouge">package/</code> directory. At the same time, we need to add it in <code class="highlighter-rouge">package/Makefile.in</code> file in order to Buildroot be able to list it.</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">echo</span> <span class="s1">'include package/pkg-conan.mk'</span> <span class="o">&gt;&gt;</span> package/Makefile.in</code></pre></figure>

<p>For script development we will break it down into a few steps. Because it is a large file, we will only portray parts of it in this post, but the full version can be found <a href="https://github.com/conan-community/buildroot/blob/feature/conan/package/pkg-conan.mk">here</a>.</p>

<p>Buildroot defines its settings, including processor, compiler version, and build type through variables. However, these variables do not have directly valid values for Conan, so we need to parse most of them. Letâ€™s start with the compiler version, by default Buildroot uses a GCC-based toolchain, so we will only filter on its possible versions:</p>

<figure class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="nv">CONAN_SETTING_COMPILER_VERSION</span>  <span class="o">?=</span>
<span class="k">ifeq</span> <span class="nv">($(BR2_GCC_VERSION_8_X),y)</span>
<span class="nv">CONAN_SETTING_COMPILER_VERSION</span> <span class="o">=</span> 8
<span class="err">else</span> <span class="k">ifeq</span> <span class="nv">($(BR2_GCC_VERSION_7_X),y)</span>
<span class="nv">CONAN_SETTING_COMPILER_VERSION</span> <span class="o">=</span> 7
<span class="err">else</span> <span class="k">ifeq</span> <span class="nv">($(BR2_GCC_VERSION_6_X),y)</span>
<span class="nv">CONAN_SETTING_COMPILER_VERSION</span> <span class="o">=</span> 6
<span class="err">else</span> <span class="k">ifeq</span> <span class="nv">($(BR2_GCC_VERSION_5_X),y)</span>
<span class="nv">CONAN_SETTING_COMPILER_VERSION</span> <span class="o">=</span> 5
<span class="err">else</span> <span class="k">ifeq</span> <span class="nv">($(BR2_GCC_VERSION_4_9_X),y)</span>
<span class="nv">CONAN_SETTING_COMPILER_VERSION</span> <span class="o">=</span> 4.9
<span class="err">endif</span></code></pre></figure>

<p>This same process should be repeated for build_type, arch, and so on. For the Conan package installation step we will have the following routine:</p>

<figure class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="err">define</span> <span class="err">$(2)_BUILD_CMDS</span>
    <span class="err">$$(TARGET_MAKE_ENV)</span> <span class="err">$$(CONAN_ENV)</span> <span class="err">$$($$(PKG)_CONAN_ENV)</span> <span class="err">\</span>
        <span class="nv">CC</span><span class="o">=</span><span class="err">$</span><span class="nv">$(TARGET_CC)</span> <span class="nv">CXX</span><span class="o">=</span><span class="err">$</span><span class="nv">$(TARGET_CXX)</span> <span class="se">\</span>
        <span class="err">$</span><span class="nv">$(CONAN)</span> <span class="nb">install</span> <span class="err">$</span><span class="nv">$(CONAN_OPTS)</span> <span class="err">$$</span><span class="o">(</span><span class="err">$</span><span class="nv">$(PKG)</span>_CONAN_OPTS<span class="o">)</span> <span class="se">\</span>
        <span class="err">$$</span><span class="o">(</span><span class="err">$</span><span class="nv">$(PKG)</span>_REFERENCE<span class="o">)</span> <span class="se">\</span>
        <span class="nt">-s</span> <span class="nv">build_type</span><span class="o">=</span><span class="err">$</span><span class="nv">$(CONAN_SETTING_BUILD_TYPE)</span> <span class="se">\</span>
        <span class="nt">-s</span> <span class="nb">arch</span><span class="o">=</span><span class="err">$</span><span class="nv">$(CONAN_SETTING_ARCH)</span> <span class="se">\</span>
        <span class="nt">-s</span> <span class="nv">compiler</span><span class="o">=</span><span class="err">$</span><span class="nv">$(CONAN_SETTING_COMPILER)</span> <span class="se">\</span>
        <span class="nt">-s</span> compiler.version<span class="o">=</span><span class="err">$</span><span class="nv">$(CONAN_SETTING_COMPILER_VERSION)</span> <span class="se">\</span>
        <span class="nt">-g</span> deploy <span class="se">\</span>
        <span class="nt">--build</span> <span class="err">$</span><span class="nv">$(CONAN_BUILD_POLICY)</span>
<span class="err">endef</span></code></pre></figure>

<p>The Conan install command will be executed as usual, but the settings and options are configured through what was previously collected from Buildroot, and accept new ones through the Buildroot package recipe. Because it was a scenario where previously all sources were compiled in the first moment, we will set Conan build policy to <code class="highlighter-rouge">missing</code>, so any package will be built if not available.</p>

<p>Also, note that we are using the generator <code class="highlighter-rouge">deploy</code>, as we will need to copy all the artifacts into the Buildroot internal structure. Once built, we will copy the libraries, executables and headers through the following routine:</p>

<figure class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="err">define</span> <span class="err">$(2)_INSTALL_CMDS</span>
    <span class="nl">cp -f -a $$($$(PKG)_BUILDDIR)/bin/. /usr/bin 2&gt;/dev/null || </span><span class="o">:</span>
    <span class="nl">cp -f -a $$($$(PKG)_BUILDDIR)/lib/. /usr/lib 2&gt;/dev/null || </span><span class="o">:</span>
    <span class="nl">cp -f -a $$($$(PKG)_BUILDDIR)/include/. /usr/include 2&gt;/dev/null || </span><span class="o">:</span>
<span class="err">endef</span></code></pre></figure>

<p>With this script we will be able to install the vast majority of Conan packages, using only simpler information for each Buildroot recipe.</p>

<h2 id="installing-conan-zlib">Installing Conan Zlib</h2>

<p>Once we have our script for installing Conan packages, now letâ€™s install a fairly simple and well-known project: <strong>zlib</strong>. For this we will create a new recipe in the package directory. Letâ€™s start with the package configuration file:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nb">mkdir </span>package/conan-zlib
<span class="nb">touch </span>package/conan-zlib/Config.in
<span class="nb">touch </span>package/conan-zlib/conan-zlib.mk</code></pre></figure>

<p>The contents of the file <em>Config.in</em> should be as follows:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">config BR2_PACKAGE_CONAN_ZLIB
    bool "conan-zlib"
    help
      Standard (de)compression library. Used by things like
      gzip and libpng.

      http://www.zlib.net</code></pre></figure>

<p>Now letâ€™s go to the <em>conan-zlib.mk</em> that contains the Zlib data:</p>

<figure class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="c"># conan-zlib.mk
</span><span class="nv">CONAN_ZLIB_VERSION</span> <span class="o">=</span> 1.2.11
<span class="nv">CONAN_ZLIB_LICENSE</span> <span class="o">=</span> Zlib
<span class="nv">CONAN_ZLIB_LICENSE_FILES</span> <span class="o">=</span> licenses/LICENSE
<span class="nv">CONAN_ZLIB_SITE</span> <span class="o">=</span> <span class="nf">$(</span><span class="nb">call</span> github,conan-community,conan-zlib,92d34d0024d64a8f307237f211e43ab9952ef0a1<span class="nf">)</span>
<span class="nv">CONAN_ZLIB_REFERENCE</span> <span class="o">=</span> zlib/<span class="nv">$(CONAN_ZLIB_VERSION)</span>@conan/stable

<span class="err">$(eval</span> <span class="err">$(conan-package))</span></code></pre></figure>

<p>An important note here is the fact that <code class="highlighter-rouge">CONAN_ZLIB_SITE</code> is required even if not used for our purpose. If it is not present, Buildroot will raise an error during its execution. The other variables are simple, just expressing the package reference, name, version and license. Note that in the end we are calling our script which should execute Conan.</p>

<p>Once created, we still need to add it to the Buildroot configuration list. To do so, letâ€™s update the list with a new menu named <code class="highlighter-rouge">Conan</code>. In <em>package/Config.in</em> file, letâ€™s add the following section:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">menu "Conan"
    source "package/conan-zlib/Config.in"
endmenu</code></pre></figure>

<p>Now just select the package through menuconfig:</p>

<p><code class="highlighter-rouge">Target Packages -&gt; Conan -&gt; conan-zlib</code></p>

<p><img src="http://localhost:4000/assets/post_images/2019-08-27/conan-buildroot-conan-menuconfig.png" style="display: block;margin: 0 auto;" /></p>

<p>Once configured and saved, simply run <code class="highlighter-rouge">make</code> again to install the package. During its installation we will have the following output:</p>

<div align="center">
    <figure>
        <img src="http://localhost:4000/assets/post_images/2019-08-27/conan-build.gif" width="800" />
        <figcaption>Buildroot build</figcaption>
    </figure>
</div>

<p>As you can see, Conan is following the same profile used by Buildroot, which gives us the advantage of not having to create a profile manually.</p>

<p>At the end of the installation it will be copied to the output directory.</p>

<h2 id="customizing-conan-remote">Customizing Conan remote</h2>

<p>Letâ€™s say we have an <a href="https://docs.conan.io/en/latest/uploading_packages/artifactory_ce.html">Artifactory</a> instance where all packages are available for download. How could we customize the remote used by Buildroot? We need to introduce a new option, where we can write the remote name and Conan will be able to consume such variable. First we need to create a new configuration file to insert new options in Conanâ€™s menu:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">mkdir </span>package/conan
<span class="nv">$ </span><span class="nb">touch </span>package/conan/Config.in</code></pre></figure>

<p>The file <em>Config.in</em> should contain:</p>

<figure class="highlight"><pre><code class="language-text" data-lang="text">config CONAN_REMOTE_NAME
	string "Conan remote name"
    help
	  Look in the specified remote server.</code></pre></figure>

<p>Also, we need to parse the option <code class="highlighter-rouge">CONAN_REMOTE_NAME</code> in <em>pkg-conan.mk</em> and add it to Conan command line:</p>

<figure class="highlight"><pre><code class="language-makefile" data-lang="makefile"><span class="k">ifneq</span> <span class="nv">($(CONAN_REMOTE_NAME),"")</span>
<span class="nv">CONAN_REMOTE</span> <span class="o">=</span> <span class="nt">-r</span> <span class="err">$</span><span class="nv">$(CONAN_REMOTE_NAME)</span>
<span class="k">endif</span>

<span class="err">...</span>

<span class="err">define</span> <span class="err">$(2)_BUILD_CMDS</span>
    <span class="err">$$(TARGET_MAKE_ENV)</span> <span class="err">$$(CONAN_ENV)</span> <span class="err">$$($$(PKG)_CONAN_ENV)</span> <span class="err">\</span>
        <span class="nv">CC</span><span class="o">=</span><span class="err">$</span><span class="nv">$(TARGET_CC)</span> <span class="nv">CXX</span><span class="o">=</span><span class="err">$</span><span class="nv">$(TARGET_CXX)</span> <span class="se">\</span>
        <span class="err">$</span><span class="nv">$(CONAN)</span> <span class="nb">install</span> <span class="err">$</span><span class="nv">$(CONAN_OPTS)</span> <span class="err">$$</span><span class="o">(</span><span class="err">$</span><span class="nv">$(PKG)</span>_CONAN_OPTS<span class="o">)</span> <span class="se">\</span>
        <span class="err">$$</span><span class="o">(</span><span class="err">$</span><span class="nv">$(PKG)</span>_REFERENCE<span class="o">)</span> <span class="se">\</span>
        <span class="nt">-s</span> <span class="nv">build_type</span><span class="o">=</span><span class="err">$</span><span class="nv">$(CONAN_SETTING_BUILD_TYPE)</span> <span class="se">\</span>
        <span class="nt">-s</span> <span class="nb">arch</span><span class="o">=</span><span class="err">$</span><span class="nv">$(CONAN_SETTING_ARCH)</span> <span class="se">\</span>
        <span class="nt">-s</span> <span class="nv">compiler</span><span class="o">=</span><span class="err">$</span><span class="nv">$(CONAN_SETTING_COMPILER)</span> <span class="se">\</span>
        <span class="nt">-s</span> compiler.version<span class="o">=</span><span class="err">$</span><span class="nv">$(CONAN_SETTING_COMPILER_VERSION)</span> <span class="se">\</span>
        <span class="nt">-g</span> deploy <span class="se">\</span>
        <span class="nt">--build</span> <span class="err">$</span><span class="nv">$(CONAN_BUILD_POLICY)</span> <span class="se">\</span>
        <span class="err">$</span><span class="nv">$(CONAN_REMOTE)</span>
<span class="err">endef</span></code></pre></figure>

<p>Now we are ready to set our specific remote name. We only need to run <code class="highlighter-rouge">make menuconfig</code> and follow the path:</p>

<p><code class="highlighter-rouge">Target Packages -&gt; Libraries -&gt; Conan -&gt; Conan remote name</code></p>

<p>And we will see:</p>

<div align="center">
    <figure>
        <img src="http://localhost:4000/assets/post_images/2019-08-27/conan-buildroot-conan-remote.png" width="500" />
        <figcaption>Buildroot build</figcaption>
    </figure>
</div>

<p>Now Conan is configured to search for packages in the remote named <em>artifactory</em>. But we need to run <code class="highlighter-rouge">make</code> again.
Note that it will cost less time to build, since now we have the cache provided by Buildroot. Now we are ready for the last step.</p>

<h2 id="installing-the-image">Installing the Image</h2>

<p>After two hours and a few coffees and if no errors have occurred during the process we will have the following output:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">ls </span>output/images/
  bcm2710-rpi-3-b.dtb bcm2710-rpi-3-b-plus.dtb bcm2710-rpi-cm3.dtb boot.vfat rootfs.ext2 rootfs.ext4 rpi-firmware sdcard.img zImage

<span class="nv">$ </span><span class="nb">ls</span> <span class="nt">-lh</span> output/images/sdcard.img
    <span class="nt">-rw-r--r--</span> 1 conan conan 153M ago  6 11:43 output/images/sdcard.img</code></pre></figure>

<p>These artifacts are the final compilation of everything that was generated during the build process, here we will be interested in the <em>sdcard.img</em> file. This is the final image that we will use on our RaspberryPi3 and it is only 153MB. Compared to other embedded distributions like Raspbian, it is much smaller.</p>

<p>Now letâ€™s copy the image to the destination SD card:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="nv">$ </span><span class="nb">sudo dd </span><span class="k">if</span><span class="o">=</span>output/images/sdcard.img <span class="nv">of</span><span class="o">=</span>/dev/mmcblk0 <span class="nv">bs</span><span class="o">=</span>4M <span class="nv">conv</span><span class="o">=</span><span class="nb">sync </span><span class="nv">status</span><span class="o">=</span>progress</code></pre></figure>

<p>Remember that the mounting point of your SD card may vary depending on your distribution.</p>

<p>Once done, plug the SD Card into the RaspberryPi3 and power the card, already connected to a video output. You will see the bootloader running normally and finally you will be presented to login screen where the default user is <strong>root</strong>, no password needed.</p>

<h2 id="conclusions">Conclusions</h2>

<p>In this post we talked about how to use Buildroot to create a Linux distribution without much effort and resulting in a very lean image.</p>

<p>Buildroot helps automate the process of creating a custom embedded Linux distribution with only the developer packages of interest.</p>

<p>Although the build process may take a few hours, with Conan integrating and replacing a few packages, this time can be reduced to just a few minutes.</p>

<p>Interested in knowing more or commenting on the subject? Please do not hesitate to open a new <a href="https://github.com/conan-io/conan/issues">issue</a>.</p>
:ET