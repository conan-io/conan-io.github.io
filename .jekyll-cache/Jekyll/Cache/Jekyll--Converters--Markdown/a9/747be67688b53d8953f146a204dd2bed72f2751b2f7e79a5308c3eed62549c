I"P;<p>In the previous blog post <a href="http://blog.conan.io/2018/01/30/Cross-building-Boost-Android.html">Cross building Boost C++ libraries to Android with Conan</a>
we cross built the Boost C++ libraries to Android and explained how to upload them to a conan server.
That way, developers in our organization can reuse them without having to build from sources again the same binaries.</p>

<p>In this post we will describe how to use these prebuilt Boost libraries in an Android Studio project.</p>

<p><strong>Note</strong>: This blog post assume that you followed the previous blog post and you have:</p>

<ul>
  <li>Profile created for target <strong>armveabi-v7</strong>, api <strong>level 21</strong> and <strong>clang</strong>: <code class="highlighter-rouge">~/.conan/profiles/android_21_armeabi-v7_clang</code></li>
  <li>Boost package uploaded to a remote server (or in our local conan cache).</li>
  <li>The conan client installed with a remote configured to point to the server where we uploaded the package (not necessary if we are using our local conan cache).</li>
</ul>

<p>Open the Android Studio and create a new app called <strong>MyBoostApp</strong> including the c++ support:</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-02-13/wizard1.png" align="center" width="500" />
</p>

<p>Select the API level (we are using 21), to match the one  that was used to cross build the Boost libraries.</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-02-13/wizard2.png" align="center" width="500" />
</p>

<p>Create an empty activity:</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-02-13/wizard3.png" align="center" width="500" />
</p>

<p>And name it MainActivity:</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-02-13/wizard4.png" align="center" width="500" />
</p>

<p>Finally, in the wizard’s last dialog, select the defaults:</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-02-13/wizard5.png" align="center" width="500" />
</p>

<p>Change to the project view:</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-02-13/menu_project.png" align="center" width="200" />
</p>

<p>And in the app folder create a <code class="highlighter-rouge">conanfile.txt</code> with the following contents:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[requires]
boost/1.66.0@conan/stable

[generators]
cmake
</code></pre></div></div>

<p>Open the <code class="highlighter-rouge">CMakeLists.txt</code> file from the app folder and replace the contents with:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmake_minimum_required(VERSION 3.4.1)

include(${CMAKE_CURRENT_SOURCE_DIR}/conan_build/conanbuildinfo.cmake)
set(CMAKE_CXX_COMPILER_VERSION "5.0") # Unknown miss-detection of the compiler by CMake
conan_basic_setup(TARGETS)

add_library(native-lib SHARED src/main/cpp/native-lib.cpp)
target_link_libraries(native-lib CONAN_PKG::boost)
</code></pre></div></div>

<p>The <code class="highlighter-rouge">CMakeLists.txt</code> above is:</p>

<ul>
  <li>
    <p>Including the file “conanbuildinfo.cmake”. This file will be generated by conan, and contains all
the information about how to link with our dependencies, in this case with Boost, but we could add
other dependencies in the <code class="highlighter-rouge">conanfile.txt</code>.</p>
  </li>
  <li>
    <p>Adding a native library <strong>native-lib</strong> and linking it with the Boost libraries.</p>
  </li>
</ul>

<p>Open the <code class="highlighter-rouge">app/build.gradle</code> file:</p>

<ul>
  <li>
    <p>In the <strong>android/defaultConfig</strong> section, specify the usage of <strong>armeabi-v7a</strong> and the <strong>c++_shared</strong> standard library.</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ndk {
     abiFilters 'armeabi-v7a'
     stl 'c++_shared'
  }
</code></pre></div>    </div>
  </li>
  <li>
    <p>In the <strong>android/defaultConfig/externalNativeBuild</strong> section add the <strong>-DANDROID_STL=c++shared</strong> argument
to force CMake to use the right stl:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>externalNativeBuild {
     cmake {
         cppFlags ""
         arguments "-DANDROID_STL=c++_shared"
     }
}
</code></pre></div>    </div>
  </li>
</ul>

<p>Finally we are adding a new task after the android block that will call Conan to retrieve the needed
Boost packages and generate the mentioned <code class="highlighter-rouge">conanbuildinfo.cmake</code> file.</p>

<p>We are going to use the <strong>android_21_armeabi-v7a_clang</strong> profile created in the previous post to
build our application for ARM, corresponding to the specified abiFilter: <strong>armeabi-v7a</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>task conanInstall {
    def buildDir = new File("app/conan_build")
    buildDir.mkdirs()
    // if you have problems running the command try to specify the absolute
    // path to conan (Known problem in MacOSX) /usr/local/bin/conan
    def conan_path = ""; // "/usr/local/bin/"
    def cmd = conan_path + "conan install ../conanfile.txt --profile android_21_armeabi-v7a_clang"
    print("&gt;&gt; ${cmd} \n")

    def sout = new StringBuilder(), serr = new StringBuilder()
    def proc = cmd.execute(null, buildDir)
    proc.consumeProcessOutput(sout, serr)
    proc.waitFor()
    println "$sout $serr"
    if(proc.exitValue() != 0){
        throw new Exception("out&gt; $sout err&gt; $serr" + "\nCommand: ${cmd}")
    }
}
</code></pre></div></div>

<p>The full <code class="highlighter-rouge">build.gradle</code> file should look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>apply plugin: 'com.android.application'

android {
   compileSdkVersion 26
   apply plugin: 'com.android.application'

android {
   compileSdkVersion 26
   defaultConfig {
       applicationId "com.jfrog.myboostapp"
       minSdkVersion 21
       targetSdkVersion 26
       versionCode 1
       versionName "1.0"
       testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"
       externalNativeBuild {
           cmake {
               cppFlags ""
               arguments "-DANDROID_STL=c++_shared"
           }
       }
       ndk {
           abiFilters 'armeabi-v7a'
           stl 'c++_shared'
       }
   }
   buildTypes {
       release {
           minifyEnabled false
           proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
       }
   }
   externalNativeBuild {
       cmake {
           path "CMakeLists.txt"
       }
   }
}

task conanInstall {
   def buildDir = new File("app/conan_build")
   buildDir.mkdirs()
   // if you have problems running the command try to specify the absolute
   // path to conan (Known problem in MacOSX) /usr/local/bin/conan
   def conan_path = "" // "/usr/local/bin/"
   def cmd = conan_path + "conan install ../conanfile.txt --profile android_21_armeabi-v7a_clang"
   print("&gt;&gt; ${cmd} \n")

   def sout = new StringBuilder(), serr = new StringBuilder()
   def proc = cmd.execute(null, buildDir)
   proc.consumeProcessOutput(sout, serr)
   proc.waitFor()
   println "$sout $serr"
   if(proc.exitValue() != 0){
       throw new Exception("out&gt; $sout err&gt; $serr" + "\nCommand: ${cmd}")
   }
}

dependencies {
   implementation fileTree(dir: 'libs', include: ['*.jar'])
   implementation 'com.android.support:appcompat-v7:26.1.0'
   implementation 'com.android.support.constraint:constraint-layout:1.0.2'
   testImplementation 'junit:junit:4.12'
   androidTestImplementation 'com.android.support.test:runner:1.0.1'
   androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.1'
}
</code></pre></div></div>

<p>Open the default example cpp library in <code class="highlighter-rouge">app/src/main/cpp/native-lib.cpp</code> and include some lines
using your library. Be careful with the <strong>JNICALL</strong> name if you used other app name in the wizard:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;jni.h&gt;
#include &lt;string&gt;
#include &lt;boost/regex.hpp&gt;
#include &lt;boost/version.hpp&gt;
#include &lt;sstream&gt;


extern "C"
JNIEXPORT jstring

JNICALL
Java_com_jfrog_myboostapp_MainActivity_stringFromJNI(
        JNIEnv *env,
        jobject /* this */) {

    std::string line;
    std::stringstream output;
    std::string sentence_with_space = "Boost Rules";

    output &lt;&lt; "Using Boost " &lt;&lt; (BOOST_VERSION / 100000) &lt;&lt; "." &lt;&lt; ((BOOST_VERSION / 100) % 1000) &lt;&lt; "." &lt;&lt; (BOOST_VERSION % 100) &lt;&lt; std::endl;

    boost::regex expr("\\w+\\s\\w+");
    if (boost::regex_match(sentence_with_space, expr)) {
        output &lt;&lt; "The regex matches! '" &lt;&lt; sentence_with_space &lt;&lt; "'" &lt;&lt; std::endl;
    }
    else{
        output &lt;&lt; "The regex doesn't match!" &lt;&lt; std::endl;
    }
    return env-&gt;NewStringUTF(output.str().c_str());
}
</code></pre></div></div>

<p>Then run the app in an ARM emulator, it takes a while because emulating this ARM is quite slow:</p>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-02-13/emulator1.png" align="center" width="300" />
</p>

<h2 id="speeding-up-emulation--building-multi-conf-apps">Speeding up emulation &amp; building multi-conf apps</h2>

<p>Running an Android emulator for ARM architecture is very slow, so if we want to test or debug our
app is always a good idea to build the application to Android/x86.
Also, applications can be distributed for different architectures in a bundle, so we are going to
repeat the process we saw in the first <a href="http://blog.conan.io/2018/01/30/Cross-building-Boost-Android.html">blog post</a>
for more architectures:</p>

<ol>
  <li>
    <p>Build another standalone toolchain for <strong>x86</strong>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> python make_standalone_toolchain.py --arch=x86 --api=21 --stl=libc++ --install-dir=/myfolder/x86_21_toolchain
</code></pre></div>    </div>
  </li>
  <li>
    <p>Create a new profile <code class="highlighter-rouge">.conan/profiles/android_21_x86_clang</code> to target the new toolchain for <strong>x86</strong>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> standalone_toolchain=/myfolder/x86_21_toolchain
 target_host=i686-linux-android
 cc_compiler=clang
 cxx_compiler=clang++

 [settings]
 compiler=clang
 compiler.version=5.0
 compiler.libcxx=libc++
 os=Android
 os.api_level=21
 arch=x86
 build_type=Release

 [env]
 CONAN_CMAKE_FIND_ROOT_PATH=$standalone_toolchain/sysroot
 PATH=[$standalone_toolchain/bin]
 CHOST=$target_host
 AR=$target_host-ar
 AS=$target_host-as
 RANLIB=$target_host-ranlib
 CC=$target_host-$cc_compiler
 CXX=$target_host-$cxx_compiler
 LD=$target_host-ld
 STRIP=$target_host-strip
 CFLAGS= -fPIC  -I$standalone_toolchain/include/c++/4.9.x
 CXXFLAGS= -fPIC  -I$standalone_toolchain/include/c++/4.9.x
 LDFLAGS=
</code></pre></div>    </div>
  </li>
  <li>
    <p>In the <code class="highlighter-rouge">app/build.gradle</code> file add <strong>x86</strong> to the abiFilters, to build the app also for x86</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> ndk {
    abiFilters 'armeabi-v7a', 'x86'
    stl 'c++_shared'
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>Adjust the task <strong>conanInstall</strong> to iterate all the declared abiFilters and install several versions
of Boost using the different profiles, this new version of the task is generic and valid for any
architecture we could add to the <strong>abiFilters</strong>:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> task conanInstall {
    android.defaultConfig.ndk.abiFilters.each {
        def arch = it;
        def buildDir = new File("app/conan_build_" + arch)
        buildDir.mkdirs()

        // if you have problems running the command try to specify the absolute
        // path to conan (Known problem in MacOSX) /usr/local/bin
        def conan_path = ""; // "/usr/local/bin/"
        def cmd = conan_path + "conan install ../conanfile.txt --profile android_21_" + arch + "_clang"
        print("&gt;&gt; ${cmd} \n")

        def sout = new StringBuilder(), serr = new StringBuilder()
        def proc = cmd.execute(null, buildDir)

        proc.consumeProcessOutput(sout, serr)
        proc.waitFor()
        println "$sout $serr"
        if (proc.exitValue() != 0) {
            throw new Exception("out&gt; $sout err&gt; $serr" + "\nCommand: ${cmd}")
        }
    }
 }
</code></pre></div>    </div>
  </li>
  <li>
    <p>Also adjust CMake to find the correct <code class="highlighter-rouge">conanbuildinfo.cmake</code> according to the architecture being built:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> cmake_minimum_required(VERSION 3.4.1)

 include(${CMAKE_CURRENT_SOURCE_DIR}/conan_build_${ANDROID_ABI}/conanbuildinfo.cmake)
 set(CMAKE_CXX_COMPILER_VERSION "5.0") # Unknown miss-detection of the compiler by CMake
 conan_basic_setup(TARGETS)

 add_library(native-lib SHARED src/main/cpp/native-lib.cpp)
 target_link_libraries(native-lib CONAN_PKG::boost)
</code></pre></div>    </div>
  </li>
  <li>
    <p>Create a new conan package for the configuration:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> conan install boost/1.66.0@conan/stable --build missing --profile=android_21_x86_clang
</code></pre></div>    </div>
  </li>
  <li>
    <p>If you want to share the binaries with your team upload them to a server:</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code> conan upload boost/1.66.0@conan/stable --all -r=myremote
 conan upload zlib* --all -r=myremote
 conan upload bzip2* --all -r=myremote
 # or just
 conan upload * --all -r=myremote
</code></pre></div>    </div>
  </li>
  <li>
    <p>Run the application in a x86 emulator!</p>
  </li>
</ol>

<p class="centered">
    <img src="http://localhost:4000/assets/post_images/2018-02-13/emulator2.png" align="center" width="300" />
</p>

<p>Now your application accepts more architectures in the <strong>abiFilters</strong>, for example <strong>arm64-v8a</strong> to target
<strong>armv8</strong>, follow the same steps to create the standalone toolchain and a new profile <strong>android_21_arm64-v8a_clang</strong></p>

<p>Building (manually or by a CI server) all packages that your team is going to use and uploading them
to a server will save a lot time in your development workflow.</p>

<p>You can find the example project in <a href="https://github.com/lasote/android-conan-blog-post">this repository</a></p>
:ET